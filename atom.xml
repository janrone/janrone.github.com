<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Janrone's Blog]]></title>
  <subtitle><![CDATA[The gold housese in the books .]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://janrone.allone.top/"/>
  <updated>2020-01-16T02:52:59.534Z</updated>
  <id>http://janrone.allone.top/</id>
  
  <author>
    <name><![CDATA[Janrone]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[三种碰撞检测]]></title>
    <link href="http://janrone.allone.top/2018/04/04/%E4%B8%89%E7%A7%8D%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/"/>
    <id>http://janrone.allone.top/2018/04/04/三种碰撞检测/</id>
    <published>2018-04-04T08:36:09.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<h3 id="u78B0_u649E_u68C0_u6D4B"><a href="#u78B0_u649E_u68C0_u6D4B" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><p>碰撞检测技术<br>可通过多种方式检测 sprite 之间的碰撞。可采用的三种流行技术（按先进程度和复杂度递增顺序排列）是：</p>
<p>边界区域（在 3D 游戏中称为包围体）<br>光线投射<br>分离轴定理 (Separating Axis Theorem)<br>使用边界区域的碰撞检测，检测圆圈或多边形的交点。在 图 2 中的示例中，小圆圈是表示一个 sprite（一个小球）的边界区域，大圆圈是一个桶的 sprite 的边界区域，桶比球大。当两个圆形边界区域相交时，球就会掉落到桶中。</p>
<p>图 2. 边界区域：圆圈之间的碰撞<br> <img src="/images/post/2018/circle-collision.jpg" alt=""></p>
<p>该图演示了圆圈之间的碰撞检测的原理<br>检测两个圆圈的碰撞是所有碰撞检测技术中最简单的。如果两个圆圈中心之间距离小于圆圈的半径之和，就会相交，sprite 就会爆炸。</p>
<p>边界区域碰撞检测很简单，但当边界区域太小或移动得太快时，检测可能失败。在这两种情况下，sprite 可在单个动画帧中彼此穿过，进而避免检测。</p>
<p>对于小型、快速移动的 sprite，更加可靠的一种技术是光线投射，如 图 3 所示。光线投射检测两个 sprite 的速度向量的焦点。在 图 3 中的 5 个帧中，球的速度向量是以蓝色绘制的对角线，桶的速度向量是红色的水平线（桶水平移动）。在这些向量的交点位于桶顶部的开口内，并且球在开口下方时，球就会落入桶中，如 图 3 中最右边的屏幕截图中所示。</p>
<p>图 3. 光线投射<br> <img src="/images/post/2018/ray-casting-closeup.jpg" alt=""></p>
<p>该图演示了光线投射碰撞检测的原理<br>先验或后验碰撞检测<br>可在碰撞发生之前（先验）或之后（后验）它们。如果在碰撞发生之前进行检测，必须预测 sprite 未来将位于何处。如果在碰撞发生之后检测，通常需要将已碰撞的 sprite 分开。这两种方法孰优孰劣并不明显。</p>
<p>光线投射非常适合以下环境中的简单形状（比如 图 2 中球落在桶中），其中给出了两个形状的速度向量的焦点，很容易确定它们是否已经发生碰撞。</p>
<p>对于更复杂的场景，比如任意大小和形状的多边形之间的碰撞，分离轴定理是最可靠的（和最复杂的）碰撞检测技术之一。分离轴定理是将光线从两个不同的角度照射到两个多边形上的数学描述，如 图 4 中所示。如果多边形背后的墙上的影子露出空隙，那么多边形没有发生碰撞。</p>
<p>图 4. 分离轴定理<br> <img src="/images/post/2018/sat.jpg" alt=""></p>
<p>该图演示了使用分离轴定理的碰撞检测的原理<br>本文不会进一步介绍光线投射或分离轴定理。您可以在 Core HTML5 Canvas（Prentice Hall，2012 年）中查阅每种方法的深入讨论。（请参阅 参考资料，获取相关链接。）</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u78B0_u649E_u68C0_u6D4B"><a href="#u78B0_u649E_u68C0_u6D4B" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><p>碰撞检测技术<br>可通过多种方式检测 spri]]>
    </summary>
    
      <category term="游戏" scheme="http://janrone.allone.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="游戏" scheme="http://janrone.allone.top/categories/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在Excel中使用宏 (版本2013)]]></title>
    <link href="http://janrone.allone.top/2018/04/04/%E5%A6%82%E4%BD%95%E5%9C%A8Excel%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%8F/"/>
    <id>http://janrone.allone.top/2018/04/04/如何在Excel中使用宏/</id>
    <published>2018-04-04T08:36:09.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<h3 id="u9700_u6C42_u83B7_u53D6_u7F51_u9875_u6570_u636E_u5230Excel_uFF0C_u7528_u6765_u7EDF_u8BA1_u3002"><a href="#u9700_u6C42_u83B7_u53D6_u7F51_u9875_u6570_u636E_u5230Excel_uFF0C_u7528_u6765_u7EDF_u8BA1_u3002" class="headerlink" title="需求获取网页数据到Excel，用来统计。"></a>需求获取网页数据到Excel，用来统计。</h3><h2 id="1_uFF0C_u521B_u5EFA_u5B8F_uFF1A"><a href="#1_uFF0C_u521B_u5EFA_u5B8F_uFF1A" class="headerlink" title="1，创建宏："></a>1，创建宏：</h2><p>新建Excel文档，点击视图，点击宏，创建 ，之后是编写宏。保存的时候，遇到到如下问题： 单击否，然后保存文件为 .xlsm 格式 。</p>
<p> <img src="../images/post/2018/excel01.png =200x200" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u9700_u6C42_u83B7_u53D6_u7F51_u9875_u6570_u636E_u5230Excel_uFF0C_u7528_u6765_u7EDF_u8BA1_u3002"><a href="#u9700_u6C42_u83B7_u53D6_u7]]>
    </summary>
    
      <category term="Android" scheme="http://janrone.allone.top/tags/Android/"/>
    
      <category term="Office" scheme="http://janrone.allone.top/categories/Office/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何删除git历史记录]]></title>
    <link href="http://janrone.allone.top/2018/03/16/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4git%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/"/>
    <id>http://janrone.allone.top/2018/03/16/如何删除git历史记录/</id>
    <published>2018-03-16T02:36:09.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<h3 id="u6E05_u9664_u6240_u6709_u5386_u53F2"><a href="#u6E05_u9664_u6240_u6709_u5386_u53F2" class="headerlink" title="清除所有历史"></a>清除所有历史</h3><p>Step 1: remove all history</p>
<pre><code>rm -rf .git
</code></pre><p>Step 2: reconstruct the Git repo with only the current content</p>
<pre><code>git init
git add .
git commit -m &quot;Initial commit&quot;
</code></pre><p>Step 3: push to GitHub.</p>
<pre><code>git remote add origin &lt;github-uri&gt;
git push -u --force origin master
</code></pre><h3 id="u6E05_u7A7A_u4E0A_u67D0_u4E2A_u6587_u4EF6_u7684_u5386_u53F2"><a href="#u6E05_u7A7A_u4E0A_u67D0_u4E2A_u6587_u4EF6_u7684_u5386_u53F2" class="headerlink" title="清空上某个文件的历史"></a>清空上某个文件的历史</h3><p>首先cd 进入项目文件夹下，然后执行以下代码：</p>
<pre><code>git filter-branch --force --index-filter &apos;git rm --cached --ignore-unmatch 文件名&apos; --prune-empty --tag-name-filter cat -- --all

git push origin master --force

rm -rf .git/refs/original/

git reflog expire --expire=now --all

git gc --prune=now

git gc --aggressive --prune=now
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u6E05_u9664_u6240_u6709_u5386_u53F2"><a href="#u6E05_u9664_u6240_u6709_u5386_u53F2" class="headerlink" title="清除所有历史"></a>清除所有历史</h3]]>
    </summary>
    
      <category term="Git" scheme="http://janrone.allone.top/tags/Git/"/>
    
      <category term="Git" scheme="http://janrone.allone.top/categories/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JSON 解析时自动判断是Object还是Array]]></title>
    <link href="http://janrone.allone.top/2017/11/17/JSON%20%E8%A7%A3%E6%9E%90%E6%97%B6%E8%87%AA%E5%8A%A8%E5%88%A4%E6%96%AD%E6%98%AFObject%E8%BF%98%E6%98%AFArray/"/>
    <id>http://janrone.allone.top/2017/11/17/JSON 解析时自动判断是Object还是Array/</id>
    <published>2017-11-17T06:36:09.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<h3 id="u540E_u7AEFAPI_u6570_u636E_u8FD4_u56DE_u6709_u65F6_u5019_u662FObject_u6709_u65F6_u5019_u6709_u662FArray_uFF01"><a href="#u540E_u7AEFAPI_u6570_u636E_u8FD4_u56DE_u6709_u65F6_u5019_u662FObject_u6709_u65F6_u5019_u6709_u662FArray_uFF01" class="headerlink" title="后端API数据返回有时候是Object有时候有是Array！"></a>后端API数据返回有时候是Object有时候有是Array！</h3><p>解决方案：通过JSONTokener解析，JSONTokener在解析过程中可以自动转换为对应的类型</p>
<p>代码示例如下：</p>
<pre><code>String json =&quot;{\&quot;scm\&quot;:{\&quot;key1\&quot;:\&quot;vlaue1\&quot;,\&quot;key2\&quot;:\&quot;vlaue2\&quot;}}&quot;;  
String json =&quot;{\&quot;scm\&quot;:[{\&quot;key1\&quot;:\&quot;vlaue1\&quot;,\&quot;key2\&quot;:\&quot;vlaue2\&quot;},{\&quot;key11\&quot;:\&quot;vlaue11\&quot;,\&quot;key22\&quot;:\&quot;vlaue22\&quot;}]}&quot;;  
JSONObject jsonObject =JSONObject.fromObject(json);  

Object listArray = new JSONTokener(jsonObject.getString(&quot;scm&quot;)).nextValue();  
if (listArray instanceof JSONArray){  
    JSONArray jsonArray = (JSONArray)listArray;  
    for (int k = 0; k &lt; jsonArray.size(); k++) {  
        JSONObject parameterObject = jsonArray.getJSONObject(k);  
    }  
}else if (listArray instanceof JSONObject) {  
    JSONObject jsonObject3 = (JSONObject)listArray;   
}  
</code></pre><p>最后搞定 。</p>
<p>参考：<a href="http://blog.csdn.net/xlyrh/article/details/75091353" target="_blank" rel="external">http://blog.csdn.net/xlyrh/article/details/75091353</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u540E_u7AEFAPI_u6570_u636E_u8FD4_u56DE_u6709_u65F6_u5019_u662FObject_u6709_u65F6_u5019_u6709_u662FArray_uFF01"><a href="#u540E_u7AEF]]>
    </summary>
    
      <category term="Android" scheme="http://janrone.allone.top/tags/Android/"/>
    
      <category term="Android" scheme="http://janrone.allone.top/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scrapy安装和问题处理]]></title>
    <link href="http://janrone.allone.top/2017/11/17/Scrapy%E5%AE%89%E8%A3%85%E5%92%8C%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"/>
    <id>http://janrone.allone.top/2017/11/17/Scrapy安装和问题处理/</id>
    <published>2017-11-17T06:36:09.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<h3 id="u5B89_u88C5_scrapy"><a href="#u5B89_u88C5_scrapy" class="headerlink" title="安装 scrapy"></a>安装 scrapy</h3><p>windows 安装</p>
<pre><code>pip install Scrapy
</code></pre><p>结果报错：</p>
<pre><code>building &apos;twisted.test.raiser&apos; extension
error: [WinError 2] 系统找不到指定的文件。

----------------------------------------
Command &quot;d:\python\python.exe -u -c &quot;import setuptools,
tokenize;__file__=&apos;C:\\Users\\Tuteng\\AppData\\Local\\Temp
\\pip-build-l7ra5rw5\\Twisted\\setup.py&apos;;f=getattr(tokeniz
e, &apos;open&apos;, open)(__file__);code=f.read().replace(&apos;\r\n&apos;, 
&apos;\n&apos;);f.close();exec(compile(code, __file__, &apos;exec&apos;))&quot; 
install --record 
C:\Users\Tuteng\AppData\Local\Temp\pip-yon9xl5j-record\ins
tall-record.txt --single-version-externally-managed 
--compile&quot; failed with error code 1 in 
C:\Users\Tuteng\AppData\Local\Temp\pip-build-l7ra5rw5\Twis
ted\
</code></pre><p>因为scrapy框架是基于twisted 的， 所以又要去上面那个网站：<br><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml" target="_blank" rel="external">http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml</a></p>
<h3 id="u641CTwisted"><a href="#u641CTwisted" class="headerlink" title="搜Twisted"></a>搜Twisted</h3><pre><code>Twisted, an event-driven networking engine.
Twisted, an event-driven networking engine.
  ● Twisted‑17.9.0‑cp27‑cp27m‑win32.whl
  ● Twisted‑17.9.0‑cp27‑cp27m‑win_amd64.whl
  ● Twisted‑17.9.0‑cp34‑cp34m‑win32.whl
  ● Twisted‑17.9.0‑cp34‑cp34m‑win_amd64.whl
  ● Twisted‑17.9.0‑cp35‑cp35m‑win32.whl
  ● Twisted‑17.9.0‑cp35‑cp35m‑win_amd64.whl
  ● Twisted‑17.9.0‑cp36‑cp36m‑win32.whl
  ● Twisted‑17.9.0‑cp36‑cp36m‑win_amd64.whl
</code></pre><p>  ● </p>
<p>选择对于的版本进行下载：cp35代表的是Python版本是多少，这里我的版本是python35，操作系统是win64位的，所以我这里进行Twisted‑17.5.0‑cp35‑cp35m‑win_amd64.whl 文件的下载</p>
<p>输入命令：</p>
<pre><code>pip install [whell]
注意：这里的为whell还是文件的绝对路径，并且带上文件格式.whl、
pip install E:\Download\Twisted-17.9.0-cp35-cp35m-win_amd64.w hl
Processing e:\download\twisted-17.9.0-cp35-cp35m-win_amd64.whl
Requirement already satisfied: constantly&gt;=15.1 in d:\python\lib\site-packages (from Twisted==17.9.0)
Requirement already satisfied: hyperlink&gt;=17.1.1 in d:\python\lib\site-packages (from Twisted==17.9.0)
Requirement already satisfied: zope.interface&gt;=4.0.2 in d:\python\lib\site-packages (from Twisted==17.9.0)
Requirement already satisfied: Automat&gt;=0.3.0 in d:\python\lib\site-packages (from Twisted==17.9.0)
Requirement already satisfied: incremental&gt;=16.10.1 in d:\python\lib\site-packages (from Twisted==17.9.0)
Requirement already satisfied: setuptools in d:\python\lib\site-packages (from zope.interface&gt;=4.0.2-&gt;Twisted==17.9.0)
Requirement already satisfied: six in d:\python\lib\site-packages (from Automat&gt;=0.3.0-&gt;Twisted==17.9.0)
Requirement already satisfied: attrs in d:\python\lib\site-packages (from Automat&gt;=0.3.0-&gt;Twisted==17.9.0)
Installing collected packages: Twisted
Successfully installed Twisted-17.9.0
</code></pre><h3 id="u6700_u540E_u518D_u5B89_u88C5Scrapy"><a href="#u6700_u540E_u518D_u5B89_u88C5Scrapy" class="headerlink" title="最后再安装Scrapy"></a>最后再安装Scrapy</h3><pre><code>pip install Scrapy
Collecting Scrapy
  Using cached Scrapy-1.4.0-py2.py3-none-any.whl
======================================
.....................................................................................
Installing collected packages: PyDispatcher, Scrapy
Successfully installed PyDispatcher-2.0.5 Scrapy-1.4.0
</code></pre><p>哈哈，最后安装成功 。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5B89_u88C5_scrapy"><a href="#u5B89_u88C5_scrapy" class="headerlink" title="安装 scrapy"></a>安装 scrapy</h3><p>windows 安装</p>
<pre><cod]]>
    </summary>
    
      <category term="Python" scheme="http://janrone.allone.top/tags/Python/"/>
    
      <category term="Python" scheme="http://janrone.allone.top/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android网络检测的大坑]]></title>
    <link href="http://janrone.allone.top/2017/06/07/Android%E7%BD%91%E7%BB%9C%E6%A3%80%E6%B5%8B%E7%9A%84%E5%A4%A7%E5%9D%91/"/>
    <id>http://janrone.allone.top/2017/06/07/Android网络检测的大坑/</id>
    <published>2017-06-07T06:36:09.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<p>最近发现在Android平板上的 ConnectivityManager 为 null ，查了下资料大致内容如下：</p>
<p>Android 平板 以太网 网线重插后,程序里去取getActiveNetworkInfo会等于null，没有活动网络，从而无法检查isConnected和getTypeName取得网络类型等信息，但其实是可以上网的，用WebView控件或自带的google浏览器上网正常，只是用自带的浏览器上网时第一次浏览网页会出现没有网络连接的提示框，但网页本身已经打开，而且后面的浏览都很正常，就是程序里一直获取不到getActiveNetworkInfo，除非重启机器或在android的以太网设置里把以太网的勾先去掉再打上，重新这么折腾下程序里getActiveNetworkInfo又能取得活动网络信息了.</p>
<p>Android 原生系统是不支持以太网络的连接的，这肯定是厂商定制了的，但是对于厂家定制的代码一般的都有或多或少的BUG，基本上这是属于BUG的，接口提供的不好。这应该是实际EthernetManager连接上了的，EthernetService也可以了的，IPC通信上了的。但是在connectivityManager里面，或者ConnectivitySerive里面，并没有获得这个信息（没有通知他这个接口做出改变）。建议这个时候应该用EthernetManager（各个平台，有线网络的管理类可能名字叫法不一样）.</p>
<pre><code>/** 
     * 检测网络是否可用1 
     * @param act 
     * @return 
     */  
    public boolean isNetConnected(Activity act){  

            ConnectivityManager manager = (ConnectivityManager) act    
                   .getApplicationContext().getSystemService(    
                          Context.CONNECTIVITY_SERVICE);    

            if (manager == null) {    
                return false;  // 针对平板可以直接返回 ture ，哈哈。  
            }    
            NetworkInfo networkinfo = manager.getActiveNetworkInfo();    
            if (networkinfo == null || !networkinfo.isAvailable()) {    
                return false;    
            }    
            return true;    
    }  

/** 
     * 检测网络是否可用2 
     */  
private boolean isNetConnected() {  
        PppoeManager pppoeManager = PppoeManager.getInstance();  
        EthernetManager ethernetManager = EthernetManager.getInstance();  
        ConnectivityManager connectivityManager = (ConnectivityManager)  
     getSystemService(CONNECTIVITY_SERVICE);  
        NetworkInfo networkInfo = connectivityManager.getNetworkInfo  
    (ConnectivityManager.TYPE_WIFI);  
        if (networkInfo.isConnected() || ethernetManager.isNetworkConnected()  
                || pppoeManager.getPppoeStatus().equals  
        (PppoeManager.PPPOE_STATE_CONNECT)) {  
            return true;  
        } else {  
            return false;  
        }  
    } 
</code></pre><h3 id="EthernetManager__u5C5E_u4E8EAndroid__u9690_u85CFAPI__uFF0C_u8C03_u7528_u7684_u65F6_u5019_u53C8_u5F88_u9EBB_u70E6_uFF0C_u800C_u4E14_u51FA_u4E86_u65B0_u7248_u672C_u53EF_u80FD_u5C31_u4E0D_u652F_u6301_u4E86_uFF0C_u6240_u4EE5_u8FD8_u662F_u5EFA_u8BAE_u4E0D_u8981_u4F7F_u7528_u6BD4_u8F83_u597D_u3002"><a href="#EthernetManager__u5C5E_u4E8EAndroid__u9690_u85CFAPI__uFF0C_u8C03_u7528_u7684_u65F6_u5019_u53C8_u5F88_u9EBB_u70E6_uFF0C_u800C_u4E14_u51FA_u4E86_u65B0_u7248_u672C_u53EF_u80FD_u5C31_u4E0D_u652F_u6301_u4E86_uFF0C_u6240_u4EE5_u8FD8_u662F_u5EFA_u8BAE_u4E0D_u8981_u4F7F_u7528_u6BD4_u8F83_u597D_u3002" class="headerlink" title="EthernetManager 属于Android 隐藏API ，调用的时候又很麻烦，而且出了新版本可能就不支持了，所以还是建议不要使用比较好。"></a>EthernetManager 属于Android 隐藏API ，调用的时候又很麻烦，而且出了新版本可能就不支持了，所以还是建议不要使用比较好。</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>最近发现在Android平板上的 ConnectivityManager 为 null ，查了下资料大致内容如下：</p>
<p>Android 平板 以太网 网线重插后,程序里去取getActiveNetworkInfo会等于null，没有活动网络，从而无法检查isCon]]>
    </summary>
    
      <category term="Android" scheme="http://janrone.allone.top/tags/Android/"/>
    
      <category term="Android" scheme="http://janrone.allone.top/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Gradle构建多个不同applicationId包]]></title>
    <link href="http://janrone.allone.top/2017/05/13/%E4%BD%BF%E7%94%A8Gradle%E6%9E%84%E5%BB%BA%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8CapplicationId%E5%8C%85/"/>
    <id>http://janrone.allone.top/2017/05/13/使用Gradle构建多个不同applicationId包/</id>
    <published>2017-05-13T06:36:09.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<p>假设下面是我们的目前的代码，想要哪个地址就改下API_URL重新打个包就ok了</p>
<p>public static final String API_URL = “<a href="http://www.google.com&quot;;//美国us//" target="_blank" rel="external">http://www.google.com&quot;;//美国us//</a><br>public static final String API_URL = “<a href="http://www.nanfei.com&quot;;//南非za" target="_blank" rel="external">http://www.nanfei.com&quot;;//南非za</a><br>public static final String API_URL = “<a href="http://www.baidu.com&quot;;//本地" target="_blank" rel="external">http://www.baidu.com&quot;;//本地</a></p>
<p>localRetrofit retrofit = new Retrofit.Builder().baseUrl(API_URL).client(client).addConverterFactory(GsonConverterFactory.create()) .build();</p>
<p>可是有一天，测试同事跑来说，每次测试不同版本只能安装一个app(applicationId是唯一的,会进行覆盖),他想在同一台手机上安装多个app，app之间的区别只是它们的后台服务接口地址API_URL不同，当然最好app的桌面名字能区分出来是哪个服务接口地址,这样测试就方便了</p>
<p>如何实现呢，同时打多个包肯定会想到用productFlavors，同时API_URL和app_name需要动态改变。</p>
<h3 id="1-_u79FB_u9664strings_u7684app_name"><a href="#1-_u79FB_u9664strings_u7684app_name" class="headerlink" title="1.移除strings的app_name"></a>1.移除strings的app_name</h3><p>由于app_name是动态的所以肯定不能写死了,把它删掉</p>
<h3 id="2-_u8BBE_u7F6Ebuild-gradle_u7684productFlavors"><a href="#2-_u8BBE_u7F6Ebuild-gradle_u7684productFlavors" class="headerlink" title="2.设置build.gradle的productFlavors"></a>2.设置build.gradle的productFlavors</h3><p>productFlavors {<br>  local {<br>    applicationId “com.lwp.app”<br>     buildConfigField ‘String’, ‘API_URL’, ‘“<a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a>“‘<br>     resValue “string”, “app_name”, “app”<br>      }<br>  us {<br>       applicationId “com.lwp.app.us”<br>      buildConfigField ‘String’, ‘API_URL’, ‘“<a href="http://www.google.com" target="_blank" rel="external">http://www.google.com</a>“‘<br>     resValue “string”, “app_name”, “app_us”<br>       }<br>  za {<br>    applicationId “com.lwp.app.za”<br>    buildConfigField ‘String’, ‘API_URL’, ‘“<a href="http://www.nanfei.com" target="_blank" rel="external">http://www.nanfei.com</a>“‘<br>     resValue “string”, “app_name”, “app_za”<br>    }<br>}<br>上面我们分别设置三个版本各自的applicationId,API_URL,app_name</p>
<h3 id="3-_u4EE3_u7801_u4E2D_u5F15_u7528_u52A8_u6001API_URL"><a href="#3-_u4EE3_u7801_u4E2D_u5F15_u7528_u52A8_u6001API_URL" class="headerlink" title="3.代码中引用动态API_URL"></a>3.代码中引用动态API_URL</h3><p>我们设置了不同版本的对应API_URL,代码肯定是要用它的，build完毕后。</p>
<p>直接可以用BuildConfig.API_URL，这个是动态的，不同版本会自动生成不同的值。</p>
<p>Retrofit retrofit = new Retrofit.Builder().baseUrl(BuildConfig.API_URL)            .client(client) addConverterFactory(GsonConverterFactory.create()).build();</p>
<h3 id="4-_u6267_u884Cgradlew_assembleDebug"><a href="#4-_u6267_u884Cgradlew_assembleDebug" class="headerlink" title="4.执行gradlew assembleDebug"></a>4.执行gradlew assembleDebug</h3><p>执行命令后会生成类似</p>
<p>app_local_debug.apkapp_us_debug.apkapp_za_debug.apk</p>
<p>安装完成后，桌面会显示app,app_us,app_za三个图标一样的app</p>
<p>他们功能完全一样，只是后台服务接口地址API_URL不一样。</p>
<p>这样就可以愉快的同时进行三个不同版本app测试同时互相比对数据的正确性了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>假设下面是我们的目前的代码，想要哪个地址就改下API_URL重新打个包就ok了</p>
<p>public static final String API_URL = “<a href="http://www.google.com&quot;;//美国us//" targe]]>
    </summary>
    
      <category term="Android" scheme="http://janrone.allone.top/tags/Android/"/>
    
      <category term="Android" scheme="http://janrone.allone.top/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python从入门到放弃]]></title>
    <link href="http://janrone.allone.top/2016/10/13/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <id>http://janrone.allone.top/2016/10/13/Python从入门到放弃/</id>
    <published>2016-10-13T06:36:09.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_u7B80_u4ECB"><a href="#1-_u7B80_u4ECB" class="headerlink" title="1.简介"></a>1.简介</h3><pre><code>Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。

Python的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。

第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。

第二个缺点就是代码不能加密。
</code></pre><h3 id="2-_u5B89_u88C5Python3-5"><a href="#2-_u5B89_u88C5Python3-5" class="headerlink" title="2.安装Python3.5"></a>2.安装Python3.5</h3><pre><code>目前，Python有两个版本，一个是2.x版，一个是3.x版，这两个版本是不兼容的。所以我们来学习最新的版本。

https://www.python.org/ 安装相应的版本 。
</code></pre><h3 id="3-Python_u89E3_u91CA_u5668"><a href="#3-Python_u89E3_u91CA_u5668" class="headerlink" title="3.Python解释器"></a>3.Python解释器</h3><p>由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。</p>
<pre><code>CPython

当我们从Python官方网站下载并安装好Python 3.5后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。

CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。

IPython

IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。

CPython用&gt;&gt;&gt;作为提示符，而IPython用In [序号]:作为提示符。

PyPy

PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。

绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。

Jython

Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。

IronPython

IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。

小结

Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。
</code></pre><p>本教程的所有代码只确保在CPython 3.5版本下运行。请务必在本地安装CPython（也就是从Python官方网站下载的安装程序）。</p>
<h3 id="4-Hello_World"><a href="#4-Hello_World" class="headerlink" title="4.Hello World"></a>4.Hello World</h3><pre><code>如果要让Python打印出指定的文字，可以用print()函数，然后把希望打印的文字用单引号或者双引号括起来，但不能混用单引号和双引号：

&gt;&gt;&gt; print(&apos;hello, world&apos;)
hello, world

这种用单引号或者双引号括起来的文本在程序中叫字符串。

创建calc.py 文件 写入 print(100 + 200 + 300)
执行.py文件
D:\pydemo&gt;python  calc.py
600
</code></pre><p>注意：文件名只能是英文字母、数字和下划线的组合。</p>
<h3 id="5-_u76F4_u63A5_u8FD0_u884Cpy_u6587_u4EF6"><a href="#5-_u76F4_u63A5_u8FD0_u884Cpy_u6587_u4EF6" class="headerlink" title="5.直接运行py文件"></a>5.直接运行py文件</h3><pre><code>有同学问，能不能像.exe文件那样直接运行.py文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在.py文件的第一行加上一个特殊的注释：

#!/usr/bin/env python3

print(&apos;hello, world&apos;)
然后，通过命令给hello.py以执行权限：

$ chmod a+x hello.py
就可以直接运行hello.py了。
</code></pre><p>来源：<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="external">http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000</a></p>
<h3 id="6-_u8F93_u5165_u548C_u8F93_u51FA"><a href="#6-_u8F93_u5165_u548C_u8F93_u51FA" class="headerlink" title="6.输入和输出"></a>6.输入和输出</h3><pre><code>&gt;&gt;&gt; name = input()
janrone
&gt;&gt;&gt; name
&apos;janrone&apos;

&gt;&gt;&gt; name = input(&apos;please enter your name: &apos;)
please enter your name: janrone
&gt;&gt;&gt; print(&apos;hello&apos;, name )
hello janrone
&gt;&gt;&gt;

&gt;&gt;&gt; print(&apos;1024 * 768 = &apos;, 1024 * 768)
1024 * 768 =  786432
&gt;&gt;&gt;
</code></pre><h3 id="7-_u6570_u636E_u7C7B_u578B"><a href="#7-_u6570_u636E_u7C7B_u578B" class="headerlink" title="7.数据类型"></a>7.数据类型</h3><pre><code>整数，浮点数，字符串，布尔值，空值
</code></pre><h4 id="u5B57_u7B26_u4E32_uFF1A"><a href="#u5B57_u7B26_u4E32_uFF1A" class="headerlink" title="字符串："></a>字符串：</h4><pre><code> 字符串是以单引号&apos;或双引号&quot;括起来的任意文本，比如&apos;abc&apos;，&quot;xyz&quot;等等。请注意，&apos;&apos;或&quot;&quot;本身只是一种表示方式，不是字符串的一部分，因此，字符串&apos;abc&apos;只有a，b，c这3个字符。如果&apos;本身也是一个字符，那就可以用&quot;&quot;括起来，比如&quot;I&apos;m OK&quot;包含的字符是I，&apos;，m，空格，O，K这6个字符。

如果字符串内部既包含&apos;又包含&quot;怎么办？可以用转义字符\来标识，比如：

&apos;I\&apos;m \&quot;OK\&quot;!&apos;
表示的字符串内容是：
I&apos;m &quot;OK&quot;!
</code></pre><h4 id="u5E03_u5C14_u503C_uFF1A"><a href="#u5E03_u5C14_u503C_uFF1A" class="headerlink" title="布尔值："></a>布尔值：</h4><pre><code>布尔值可以用and、or和not运算。
</code></pre><h4 id="u7A7A_u503C_uFF1A"><a href="#u7A7A_u503C_uFF1A" class="headerlink" title="空值："></a>空值：</h4><pre><code>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。
</code></pre><p>最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：</p>
<pre><code>&gt;&gt;&gt; 10 / 3
3.3333333333333335
/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：

&gt;&gt;&gt; 9 / 3
3.0
还有一种除法是//，称为地板除，两个整数的除法仍然是整数：

&gt;&gt;&gt; 10 // 3
3
你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。

因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：

&gt;&gt;&gt; 10 % 3
1
无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。
</code></pre><h4 id="u7F16_u7801_u548C_u5B57_u7B26_u4E32_u64CD_u4F5C"><a href="#u7F16_u7801_u548C_u5B57_u7B26_u4E32_u64CD_u4F5C" class="headerlink" title="编码和字符串操作"></a>编码和字符串操作</h4><pre><code>字符    ASCII        Unicode                    UTF-8
A        01000001    00000000 01000001        01000001
中        x            01001110 00101101        11100100 10111000 10101101
</code></pre><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p>
<p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。</p>
<p>Python的字符串</p>
<p>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言。</p>
<p>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：</p>
<pre><code>&gt;&gt;&gt; ord(&apos;A&apos;)
65
&gt;&gt;&gt; ord(&apos;中&apos;)
20013
&gt;&gt;&gt; chr(66)
&apos;B&apos;
&gt;&gt;&gt; chr(25991)
&apos;文&apos;
</code></pre><p>如果知道字符的整数编码，还可以用十六进制这么写str：</p>
<pre><code>&gt;&gt;&gt; &apos;\u4e2d\u6587&apos;
&apos;中文&apos;
</code></pre><p>两种写法完全是等价的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_u7B80_u4ECB"><a href="#1-_u7B80_u4ECB" class="headerlink" title="1.简介"></a>1.简介</h3><pre><code>Python是著名的“龟叔”Guido van Rossum在198]]>
    </summary>
    
      <category term="Python" scheme="http://janrone.allone.top/tags/Python/"/>
    
      <category term="Python" scheme="http://janrone.allone.top/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Studio插件推荐]]></title>
    <link href="http://janrone.allone.top/2016/07/15/Android%20Studio%20%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    <id>http://janrone.allone.top/2016/07/15/Android Studio 插件推荐/</id>
    <published>2016-07-15T06:36:09.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<h3 id="CodeGlance"><a href="#CodeGlance" class="headerlink" title="CodeGlance"></a>CodeGlance</h3><pre><code>一款生成代码缩略图，快速定位的插件，强烈推荐！
这个插件会把IDE右侧的滚动条换成代码缩略图，这样在滚动代码的时候非常便捷，极大提高了浏览代码的效率。 
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="CodeGlance"><a href="#CodeGlance" class="headerlink" title="CodeGlance"></a>CodeGlance</h3><pre><code>一款生成代码缩略图，快速定位的插件，强烈推荐！
这个插件会把]]>
    </summary>
    
      <category term="Android" scheme="http://janrone.allone.top/tags/Android/"/>
    
      <category term="Android Stuido" scheme="http://janrone.allone.top/categories/Android-Stuido/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shell命令]]></title>
    <link href="http://janrone.allone.top/2016/05/29/Shell%E5%91%BD%E4%BB%A4/"/>
    <id>http://janrone.allone.top/2016/05/29/Shell命令/</id>
    <published>2016-05-29T12:36:09.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<p>###（一）文件创建命令</p>
<h4 id="1-touch_u547D_u4EE4"><a href="#1-touch_u547D_u4EE4" class="headerlink" title="1.touch命令"></a>1.touch命令</h4><pre><code>例如：touch abc命令在本地目录中创建了一个名为abc的空文件
</code></pre><h4 id="2-cp_u547D_u4EE4"><a href="#2-cp_u547D_u4EE4" class="headerlink" title="2.cp命令"></a>2.cp命令</h4><pre><code>cp命令允许我们把一个文件的内容复制到同名或不同名的文件中，复制得到的文件可以在任何目录。
使用cp命令的一个风险    是它会在不提示用户的情况下很容易覆盖掉不同目录中的文件
-r选项支持递归复制。例如：cp -ar /usr/share/doc/. /doc/ 将复制源目录中所有子目录以及相关文件
</code></pre><h4 id="3-mv_u547D_u4EE4"><a href="#3-mv_u547D_u4EE4" class="headerlink" title="3.mv命令"></a>3.mv命令</h4><pre><code>mv命令实质上市给文件贴上不同的标签，例如：mv file1 file2 命令就是把file1的名字改为file2
mv命令也可以用于目录
</code></pre><h4 id="4-ln_u547D_u4EE4"><a href="#4-ln_u547D_u4EE4" class="headerlink" title="4.ln命令"></a>4.ln命令</h4><pre><code>链接文件允许用户编辑不同目录中的同一个文件
硬链接包含了文件的一个副本。只要硬链接文件是在同一个分区中，则它们的索引号相同 。
ln /etc/samba/smb.conf     smb.conf
软连接起着重定向的作用。当我们打开一个用软链接创建的文件时，则链接把我们重定向到原来的文件。
ln -s /etc/    samba/smb.conf smb.conf
</code></pre><h4 id="5-rm_u547D_u4EE4"><a href="#5-rm_u547D_u4EE4" class="headerlink" title="5.rm命令"></a>5.rm命令</h4><pre><code>-r开关选项可以按递归方式进行
-f开关选项可以覆盖掉任何安全措施  rm -rf  /root/a/b
</code></pre><h4 id="6-_u76EE_u5F55_u521B_u5EFA_u548C_u5220_u9664"><a href="#6-_u76EE_u5F55_u521B_u5EFA_u548C_u5220_u9664" class="headerlink" title="6.目录创建和删除"></a>6.目录创建和删除</h4><pre><code>mkdir和rmdir命令用于创建和删除目录
-p  no error if existing, make parent directories as needed
例如 mkdir -p /test1/test2/test3 
rmdir -p /test1/test2/test3
</code></pre><h4 id="7-alias_u547D_u4EE4"><a href="#7-alias_u547D_u4EE4" class="headerlink" title="7.alias命令"></a>7.alias命令</h4><pre><code>可以用来简化几个命令。对于root用户，默认的别名可以提供一点安全性
</code></pre><p>###（二）文件搜索</p>
<h4 id="1-find_u547D_u4EE4"><a href="#1-find_u547D_u4EE4" class="headerlink" title="1.find命令"></a>1.find命令</h4><pre><code>find / -name name.conf 此命令从根目录开始搜索
find /usr -name name.conf 从/usr目录下开始搜索
</code></pre><h4 id="2-locate_u547D_u4EE4"><a href="#2-locate_u547D_u4EE4" class="headerlink" title="2.locate命令"></a>2.locate命令</h4><pre><code>RHEL允许用户创建一个数据库，它保存了全部的安装文件和目录。
locate命令的缺点是此数据库通常每天只更新一次，这    在/etc/cron.daily/mlocate.cron脚本文件中有记录
这个脚本文件可以直接由root用户从命令行接口中执行。只要输入这个文件的完整目录就行
</code></pre><p>###（三）文本文件的管理</p>
<h4 id="1-cat_u547D_u4EE4"><a href="#1-cat_u547D_u4EE4" class="headerlink" title="1.cat命令"></a>1.cat命令</h4><pre><code>最简单的文本文件读取命令是cat。cat filename命令可以翻页显示filename文件的内容。
</code></pre><h4 id="2-less_u548Cmore_u547D_u4EE4"><a href="#2-less_u548Cmore_u547D_u4EE4" class="headerlink" title="2.less和more命令"></a>2.less和more命令</h4><pre><code>用more filename命令可以翻页显示文本文件的内容，每次一个屏幕从头到尾显示
用less filename命令，我们可以用PAGE UP和PAGE DOWN键向前或向后翻页查看铜件的文本
less命令有几个功能是more和cat这两个命令所没有的。它可以读取用Gzip格式压缩的文本文件，通常这种文件的扩展名为.gz
</code></pre><h4 id="3-head_u548Ctail_u547D_u4EE4"><a href="#3-head_u548Ctail_u547D_u4EE4" class="headerlink" title="3.head和tail命令"></a>3.head和tail命令</h4><pre><code>head 命令读取文件的头部
语法：$ head –n N file 打印前N行 $ head –n -N file 打印除最后N行外的所有行
tail命令总是读取文件的尾部
语法：$ tail –n N file 打印后N行 $ taill –n +N file 打印除了前N行之外的所有行
</code></pre><p>###（四）处理文本流的命令</p>
<p>文本流就是数据的流动。例如，cat filename命令把来自filename的数据流输出到屏幕上。当这些文件变大时，最好先用过滤器命令对这些流进行处理。</p>
<h4 id="1-sort_u547D_u4EE4"><a href="#1-sort_u547D_u4EE4" class="headerlink" title="1.sort命令"></a>1.sort命令</h4><p>可以用多种方法对文件的内容进行排序。默认情况下，sort命令按照字母顺序将文件内容按每行首字符进行排序。</p>
<h4 id="2-grep_u547D_u4EE4"><a href="#2-grep_u547D_u4EE4" class="headerlink" title="2.grep命令"></a>2.grep命令</h4><pre><code>grep命令用于文本搜索，默认读取一个文件的所有行
$ grep match_pattern filename 或者 $ grep “match_pattern” filename
一个grep命令也可以对多个文件进行搜索 $grep &quot;match_text&quot; file1 file2 file3 ...
grep命令通常将match_pattern视为通配符。如果要使用正则表达式，需要添加-E选项——这意味着使用扩展（extended）正则表达式，或者使用默认允许正则表达式的egrep命令。 例如： $ grep -E &quot;[a-z]+&quot; 或者 $egrep &quot;[a-z]&quot; 匹配url的正则表达式 $ egrep -o &quot;http://[a-zA-Z0-9.]+\.[a-zA-z]{2,3}&quot; index.html
--color=atuto 选项：可以在输出行中重点标记出匹配到的单词
-o选项：只输出文件中匹配到的文本部分。 例如：输出每个单词 echo this is a test file | egrep -o &quot;\b[[:alpha:]]+\b&quot;
-v选项：打印包含match_pattern的行之外的所有行
-c选项：统计文件或文本中包含匹配字符串的行数
-b选项： 打印样式匹配所位于的字符或字节偏移，选项-b总是和-o配合使用 例如：$echo gnu is not unix | grep -b -o &quot;not&quot;
其他选项：
1）递归搜索文件 $ grep &quot;text&apos; . -R -n
2)  忽略样式中的大小写 $ echo hello world | grep -i &quot;HELLO&quot;
3)  用grep匹配多个样式 $ grep -e &quot;pattern1&quot; -e &quot;pattern2&quot; 或者 在样式文件中逐行写下需要匹配的样式，然后用选项-f执行grep。 $echo hello this is cool | grep -f pat_file
4)  在grep搜索中包括或排除文件  
只在目录中递归搜索所有的.c和.cpp文件： $ grep &quot;main()&quot; . -r --include *.{c,cpp} 注意：some{string1,string2}会扩展成somestring1 somestring2
在搜索中排除所有的README文件： $ grep &quot;main()&quot; . -r --exclude &quot;README&quot;
如果要排除目录，可以使用 --exclude-dir 选项
如果需要从文件中读取所需要排除的文件列表，使用 --exclude-from FILE
5)  使用0值字节后缀的grep与xargs
在下面的命令序列中，grep输出以0值字节作为终结符的文件（\0）。这可以用grep的-Z选项来指定。xargs -0 读取输入并用0值字节终结符分割文件名：
$ grep &quot;test&quot; file* -lZ | xargs -0 rm 。-Z通常和-l结合使用
6）grep的静默输出：在静默模式（quiet mode）中，grep命令不会向标准输出打印任何输出。它仅是运行命令，然后根据命令执行成功与否返回退回状态。使用-q
7） 打印出匹配文本之前或之后的行
要打印匹配某个结果之后的3行，使用-A选项  -A NUM, --after-context=NUM。例如 $seq 10 | grep   -A 3 5
要打印匹配某个结果之前的3行，使用-B选项 -B NUM, --before-context=NUM。例如 $seq 10 | grep  -B 3 5
要打印匹配某个结果之前以及之后的3行，使用-C选项  -C NUM, -NUM, --context=NUM。例如 $seq 10 | grep-C 3 5
如果有多个匹配，那么以一行“--”作为各匹配之间的定界符。例如 $ echo -e &quot;a\nb\nc\na\nb\nc&quot; | grep a -A 1
</code></pre><h4 id="3-diff_u547D_u4EE4"><a href="#3-diff_u547D_u4EE4" class="headerlink" title="3.diff命令"></a>3.diff命令</h4><pre><code>diff命令可以找出两个文件的差别。
diff /root/ifcfg-eth0 /etc/sysconfig/network-scripts/ifcfg-eth0
</code></pre><h4 id="4-wc_u547D_u4EE4"><a href="#4-wc_u547D_u4EE4" class="headerlink" title="4.wc命令"></a>4.wc命令</h4><pre><code>wc是一个用于统计的工具。它是Word Count(单词统计)的缩写。
1）统计行数$ wc -l file
2）统计单词数 $ wc -w file
3）统计字符数 $ wc -c file
4）当不适用任何选项执行wc时：$ wc file 它只会打印文件的行数、单词数和字符数，彼此之间用制表符分割
</code></pre><h4 id="5-sed_u547D_u4EE4"><a href="#5-sed_u547D_u4EE4" class="headerlink" title="5.sed命令"></a>5.sed命令</h4><pre><code>sed命令是流编辑（stream editor）的缩写符，用于搜索并修改文件中指定的单词甚至文本流。
如果要替换所有内容，需要在命令尾部加上参数g 其方法如下：$ sed &apos;s/pattern/replace_string/g&apos; file 后缀/g意味着sed会替换每一处匹配。但是有时候我们不需要替换前N处匹配，而是需要替换剩下的匹配。当需要从第N处匹配开始替换时，可以使用/Ng 例如： $echo this thisthisthisthis | sed &apos;s/this/THIS/4g&apos;
sed常用组合命令
1）移除空白行
2) 已匹配字符串标记&amp; 
$ echo this is an example | sed &apos;s/\w\+/[&amp;]/g&apos; 正则表达式 \w\+ 匹配每一个单词，然后我们用[&amp;]替换它，&amp;对应于之前所匹配到的单词
3) 子串匹配标记\1  &amp;代表匹配给定样式的字符串
4）组合多个表达式 
5) 引用
sed可以替换给定文本中的字符串。 $ sed &apos;s/pattern/replace_string/&apos; file
-i选项：将替换结构应用于原文件。 例如：$ sed -i &apos;s/text/replace/&apos; file  等价于 $ sed &apos;s/text/replace/&apos; file &gt; newfile    ;   $mv newfile file
 $ sed &apos;/^$/d&apos; file
在sed中，用&amp;标记匹配样式的字符串，就能够在替换字符串时使用已匹配的内容
$ echo seven EIGNT | sed &apos;s/\([a-z]\+\) \([A-Z]\+\)/\2 \1/&apos;   ([a-z]\+\)匹配第一个单词 ([A-Z]\+\)匹配第二个单词 \1和、2用来引用它们。这种医用被称为向后引用（back  referencing）。在替换部分，它们的次序被更改为 \2  \1 因此结果就呈现出逆序的形式。
$ sed &apos;expression&apos; | sed &quot;expression&apos; 等价于 $ sed  &apos;expression; expression&apos;
sed表达式通常用单引号引用。不过也可以使用双引号。双引号会通过对表达式求值来对其进行扩展。当我们想在sed表达式中使用一些变量字符串时，双引号就有用武之地了。例如： $  text=hello  $echo hello world | sed &quot;s/$text/HELLO/&quot;  结果HELLO word， $text的求值结果是hello
</code></pre><h4 id="6-awk_u547D_u4EE4"><a href="#6-awk_u547D_u4EE4" class="headerlink" title="6.awk命令"></a>6.awk命令</h4><pre><code>一个awk脚本通常由3部分组成： BEGIN语句块、END语句块和能够使用模式匹配的通用语句块。
例如 echo -e &quot;line1\nline2&quot; | awk  &apos;BEGIN {print &quot;Start&quot;} {print} END{print &quot;End&quot;}‘
关于print，需要记住两件重要的事情：当print的参数是以逗号进行分割时，参数打印时则以空格作为定界符；在awk的print语句中，双引号是被当做拼接操作符（concatenation operator）使用的。例如：
$ echo | awk &apos;{ var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; \ print var1,var2,var3;}&apos; 输出 v1 v2 v3
$ echo | awk &apos;{  var1=&quot;v1&quot;; var2=&quot;v2&quot;; var3=&quot;v3&quot;; \ print var1 &quot;-&quot; var2 &quot;-&quot; var3;}&apos;  输出 v1-v2-v3
补充内容
1）特殊变量
NF：表示字段数量（number of fields ），在执行过程中对应于当前的字段数。
$0 ：这个变量包含执行过程中当前行的文本内容
$1 ：这个变量包含第一个字段的文本内容
$2 ：这个变量包含第二个字段的文本内容
例如 我们可以用print $NF打印一行中最后一个字段，用$（NF-1）打印倒数第二个字段，其他字段依次类推即可。
要打印从M行到N行这个范围内的所有文本，语法 $ awk &apos;NR==M, NR==N&apos; filename
要打印处于start_pattern与end_pattern之间的文本，语法 $ awk &apos;/start_pattern/, /end_pattern/&apos; filename 用于awk中的样式为正则表达式
2）将外部变量值传递给awk
还有另一种灵活的方法可以将多个外部变量传递给awk 例如：
$ var1=&quot;Variable1&quot; ;var2=&quot;Variable2&quot; $ echo | awk &apos;{ print v1,v2 }&apos; v1=$var1 v2=$var2
在上面的方法中，变量之间用空格分隔，以键-值对的形式（v1=$var1 v2=$var2 ）作为awk的命令行参数紧随在BEGIN、{ }和END语句块之后。
3）用getline读取行
例如：seq 5| awk &apos;BEGIN { getline;print $0}{print $0}&apos;
4）用样式对awk处理的行进行过滤 $ awk &apos;NR &lt; 5&apos; # 行号小于5的行 $ awk &apos;NR==1,NR==4&apos; #行号在1到5之间的行 $ awk &apos;/linux/&apos; # 包含样式linux的行（可以用正则表达式来指定样式） $ awk &apos;!/linux/&apos; # 不包含样式linux的行 5）设置字段定界符 在BEGIN语句块中则可以用FS=“delimiter” 设置输出字段的定界符 $ awk &apos;BEGIN {FS=&quot;:&quot;} {print $NF }&apos; /etc/passwd 6) 从awk中读取命令输出 awk支持以文本作为索引的关联数组 7) 在awk中使用循环 awk有很多内建的字符串控制函数： length(String) index(string,search_string) split(string,array,delimiter) substr(string,start-position,end-position) sub( regex, replacement_str, string) 将正则表达式匹配到的第一处内容替换成replacement_str gsub( regex, replacement_str, string) 将正则表达式匹配到的所有内容替换成replacement_str match( regex, string) 检查正则表达式是否能够匹配字符串。如果能够匹配，返回非0值；否则，返回0。match()有两个相关的特殊变量，RSTART包含正则表达式所匹配内容的起始位置，而RLENGTH包含正则表达式所匹配内容的长度。
awk被设计用于数据流。它非常有趣，其原因就在于它可以对列和行进行操作。
awk脚本的结构基本如下所示： awk &apos; BEGIN { print &quot;start&quot; } pattern { commands } END { print &quot;end&quot; } file
NR：表示记录数量（number of records），在执行过程中对应于当前行号。
。。。
$N ：这个变量包含第N个字段的文本内容
例如：$var=10000 $ echo | awk -v VARIABLE=$var &apos;{ print VARIABLE }&apos;
通常，grep默认读取一个文件的所有行。如果只想读取某一行，可以使用geiline函数。有时候，我们需要从BEGIN语句块中读取第一行。
我们可以为需要处理的行指定一些条件，例如：
默认的字段定界符是空格。我们可以用-F “delimiter”明确指定一个界定符： $ awk -F: &apos;{ print $NF }&apos; /etc/passwd
$echo | awk &apos;{ &quot;grep root /etc/password&quot; | getline cmdout; print cmdout }&apos; 通过使用getline，能够将外部shell命令的输出读入变量cmdout
在awk中可以使用for循环，其格式： for( i=0;i&lt;10;i++) { print $i; } 或者 for( i in array) { print array[i] }
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>###（一）文件创建命令</p>
<h4 id="1-touch_u547D_u4EE4"><a href="#1-touch_u547D_u4EE4" class="headerlink" title="1.touch命令"></a>1.touch命令</h4><pre>]]>
    </summary>
    
      <category term="Shell" scheme="http://janrone.allone.top/tags/Shell/"/>
    
      <category term="Shell" scheme="http://janrone.allone.top/categories/Shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node与Express开发笔记一]]></title>
    <link href="http://janrone.allone.top/2016/05/26/Node%E4%B8%8EExpress%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://janrone.allone.top/2016/05/26/Node与Express开发笔记一/</id>
    <published>2016-05-26T10:38:13.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<h3 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h3><p>JavaScript、 Node 和 Express 的组合是 Web 团队的理想选择， 这个强大的、 可快速部署的技术栈得到了开发社区和大公司的广泛认可。</p>
<p>Node 和 Express 就像发射 JavaScript 希望之银弹的机关枪。</p>
<h3 id="u521D_u8BC6Express"><a href="#u521D_u8BC6Express" class="headerlink" title="初识Express"></a>初识Express</h3><p>老实说， JavaScript 确实降低了业余选手进入的门槛， 也有很多充斥着各种问题的 JavaScript 代码， 这损坏了 JavaScript 的名声。 用句通俗的话说， 即“ 不是游戏太差， 而是玩家太烂”。</p>
<p>Express 网站上是这样介绍 Express 的：“ 精简的、 灵活的 Node.js Web 程序框架， 为构建单页、 多页及混合的 Web 程序提供了一系列健壮的功能特性。” </p>
<h4 id="u5355_u9875Web_u7A0B_u5E8F"><a href="#u5355_u9875Web_u7A0B_u5E8F" class="headerlink" title="单页Web程序"></a>单页Web程序</h4><p>单页 Web 程序是比较新颖的想法。<br>不像之前的网站， 用户每次访问不同的页面都要发起网络请求， 单页 Web 程序把整个网站（ 或很大一部分） 都下载到客户端浏览器上。经过初始下载后， 用户访问不同页面的速度更快了， 因为几乎不需要或者只要很少的服务端通信。<br>单页程序的开发可以使用 Angular 或 Ember 等流行框架， Express 跟它们都配合得很好。</p>
<p>Express 的缔造者 TJ Holowaychuk 说 Express 是在 Sinatra 的启发下创建的， 后者是一个基于 Ruby 的框架。</p>
<p>Express 从 2.x 升级到 3.0 时做了大量的改写， 从 3.x 到 4.0 时也是这样。 本书会重点介绍版本 4.0。</p>
<p>Node 和传统的 Web 服务器之间的另一个主要区别是： Node 是单线程的。</p>
<p>如果你需要多线程程序的性能， 只需启用更多的 Node 实例， 就可以得到多线程的性能优势。</p>
<h4 id="Node_uFF1A__u4E00_u79CD_u65B0_u578BWeb_u670D_u52A1_u5668"><a href="#Node_uFF1A__u4E00_u79CD_u65B0_u578BWeb_u670D_u52A1_u5668" class="headerlink" title="Node： 一种新型Web服务器"></a>Node： 一种新型Web服务器</h4><p>Node 跟其他流行的 Web 服务器， 比如微软的互联网信息服务（ IIS） 或Apache， 有很多共同点。 然而更有趣的是探究它的不同之处， 所以我们先从讨论它的不同开始。<br>Node 实现 Web 服务器的方式跟 Express 很像， 也非常精简。<br>Node 的搭建和配置非常容易，不像 IIS 或 Apache 要花费多年的时间才能掌握。</p>
<p>Node 程序更像 PHP 或 Ruby。</p>
<p>Node 所用的 JavaScript 引擎（ 谷歌的 V8） 确实会将 JavaScript 编译为本地机器码（ 更像C 或 C++）， 但这一操作是透明的 ， 所以从用户的角度来看， 它表现的还是像纯粹的解释型语言一样。 没有单独的编译步骤， 这减少了维护和部署的麻烦。 你所要做的只是更新JavaScript 文件， 然后你的修改就自动生效了。<br>Node 程序的另一个好处是它的平台无关性。</p>
<h4 id="Node__u7684_u751F_u6001_u7CFB_u7EDF"><a href="#Node__u7684_u751F_u6001_u7CFB_u7EDF" class="headerlink" title="Node 的生态系统"></a>Node 的生态系统</h4><p>“ 技术栈” 的缩略语。<br>比如说， Linux、 Apache、 MySQL 和 PHP 被称为 LAMP 栈。<br>MongoDB的工程师 Valeri Karpov 发明了一个缩略语 MEAN， 指代 Mongo、 Express、 Angular 和Node。</p>
<p>将所有这些技术结合到一起的是 JavaScript， 所以为了做到兼容并包， 我将其称为“ JavaScript 技术栈”。 对于本书而言， 即指 Node、 Express 和 MongoDB。</p>
<h3 id="u6388_u6743"><a href="#u6388_u6743" class="headerlink" title="授权"></a>授权</h3><p>GNU通用公共授权（ GPL）<br>GPL 是非常流行的开源授权， 它为保证软件的自由做了精巧的构思。 这意味着如果你在项目中用了 GPL 授权的代码， 那么你的项目必须也是 GPL 授权的。 这自然也就意味着你的项目不能是闭源的。</p>
<p>Apache 2.0<br>这个授权像 MIT 一样， 你可以为自己的项目使用不同的授权， 包括闭源的授权。 然而，你必须对那些使用 Apache 2.0 授权的组件做出声明。</p>
<p>伯克利软件分发（ BSD）<br>与 Apache 类似， 这个授权允许你为自己的项目使用任何授权， 只是你声明使用了 BSD授权的组件。</p>
<h3 id="u4ECENode_u5F00_u59CB"><a href="#u4ECENode_u5F00_u59CB" class="headerlink" title="从Node开始"></a>从Node开始</h3><p>npm 是随处可见的 Node 开发包管理器（ 我们就是用它获取并安装 Express 的）。“ npm” 跟PHP、 GNU、 WINE 等那些古怪的传统名字不一样， 它不是首字母缩写（ 所以也没有大写）， 而是“ npm 不是缩写” 的递归缩写。</p>
<pre><code>npm install npm@latest -g  //升级npm到最新版本
</code></pre><h4 id="u8FDB_u5165_Node__u7684_u9996_u9875_http_3A//nodejs-org__u3002"><a href="#u8FDB_u5165_Node__u7684_u9996_u9875_http_3A//nodejs-org__u3002" class="headerlink" title="进入 Node 的首页 http://nodejs.org 。"></a>进入 Node 的首页 <a href="http://nodejs.org" target="_blank" rel="external">http://nodejs.org</a> 。</h4><p> npm 是一个快速、高能并且毫不费力的包管理器，包管理器的两个主要职责是安装开发包和管理依赖项。</p>
<p>在使用 npm 时，（ 毫无悬念） 最主要的命令是 install。 比如要安装 Grunt（ 一个流行的JavaScript 任务执行器）， 你将会（ 在控制台里） 发起下面这个命令：<br>npm install -g grunt-cli<br>标记 -g 的意思是告诉 npm 这个包要全局安装， 即系统全局都可以访问它。</p>
<p>用Node实现的简单Web服务器</p>
<p>Node 所提供的范式跟传统的 Web 服务器不同： 你写的程序就是 Web 服务器。 Node 只是给你提供了一个构建 Web 服务器的框架。</p>
<p>如果你用的是远程的机器（ 比如通过 SSH 访问的）， 记得浏览 localhost 时访问的不是你眼前的那台机器。</p>
<h3 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h3><pre><code>  var http = require(&apos;http&apos;);
http.createServer(function(req,res){
    res.writeHead(200, { &apos;Content-Type&apos;: &apos;text/plain&apos; });
    res.end(&apos;Hello world!&apos;);
}).listen(3000);
console.log(&apos;Server started on localhost:3000; press Ctrl-C to terminate....&apos;);
</code></pre><p>确保是和 helloWorld.js 在同一个目录下， 输入 node hello World.js。<br>然后打开浏览器访问<a href="http://localhost:3000，" target="_blank" rel="external">http://localhost:3000，</a> 你的第一个 Web 服务器就建成啦！</p>
<pre><code>在开发过程中，每次修改代码保存后，我们都需要手动重启程序，才能查看改动的效果。使用 supervisor 可以解决这个繁琐的问题，全局安装 supervisor：
npm install -g supervisor
运行 supervisor --harmony index 启动程序 。
</code></pre><p>事件驱动编程Node 的核心理念是事件驱动编程。</p>
<p>路由是指向客户端提供它所发出的请求内容的机制。</p>
<pre><code>var http = require(&apos;http&apos;);
http.createServer(function(req,res){
var path = req.url.replace(/\/?(?:\?.*)?$/,&apos;&apos;).toLowerCase();
switch(path){
    case &apos;&apos;:
        res.writeHead(200,{&apos;Content-Type&apos;:&apos;text/plain&apos;});
        res.end(&apos;Homepage&apos;);
    break;
    case &apos;/about&apos;:
        res.writeHead(200,{&apos;Content-Type&apos;:&apos;text/plain&apos;});
        res.end(&apos;About&apos;);
    break;
    default:
        res.writeHead(200,{&apos;Content-Type&apos;:&apos;text/plain&apos;});
        res.end(&apos;Not Found&apos;);
    break;
}
}).listen(3000);
console.log(&apos;Server started on localhost:3000; press Ctrl-C to terminate&apos;);
</code></pre><p>运行这段代码， 你会发现现在你可以访问首页（ <a href="http://localhost" target="_blank" rel="external">http://localhost</a>: 3000） 和关于页面（ <a href="http://localhost:3000/about）。" target="_blank" rel="external">http://localhost:3000/about）。</a><br>所有查询字符串都会被忽略（ 所以 <a href="http://localhost:3000/?foo=bar" target="_blank" rel="external">http://localhost:3000/?foo=bar</a> 也是返回首页）， 并且其他所有 URL（ <a href="http://localhost:3000/foo）" target="_blank" rel="external">http://localhost:3000/foo）</a> 返回的都是未找到页面。</p>
<p>ejs 有 3 种常用标签：<br>    &lt;% code %&gt;：运行 JavaScript 代码，不输出<br>    &lt;%= code %&gt;：显示转义后的 HTML内容<br>    &lt;%- code %&gt;：显示原始 HTML 内容<br>注意：&lt;%= code %&gt; 和 &lt;%- code %&gt; 都可以是 JavaScript 表达式生成的字符串，当变量 code 为普通字符串时，两者没有区别。当 code 比如为 </p><h1>hello</h1> 这种字符串时，&lt;%= code %&gt; 会原样输出 <h1>hello</h1>，而 &lt;%- code %&gt; 则会显示 H1 大的 hello 字符串。<p></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h3><p>JavaScript、 Node 和 Express 的组合是 Web 团队的理想选择， 这个强大的、 ]]>
    </summary>
    
      <category term="express" scheme="http://janrone.allone.top/tags/express/"/>
    
      <category term="node" scheme="http://janrone.allone.top/tags/node/"/>
    
      <category term="Node" scheme="http://janrone.allone.top/categories/Node/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用Daocloud持续部署Hexo]]></title>
    <link href="http://janrone.allone.top/2016/05/10/%E5%88%A9%E7%94%A8Daocloud%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2Hexo/"/>
    <id>http://janrone.allone.top/2016/05/10/利用Daocloud持续部署Hexo/</id>
    <published>2016-05-10T05:25:42.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<h3 id="Hexo_u5B89_u88C5"><a href="#Hexo_u5B89_u88C5" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><pre><code>npm install -g hexo //安装完成后，进入到Hexo文件夹目录， 即会自动在目标文件夹建立网站所需要的所有文件。
hexo init //初始化
npm install //安装依赖包
hexo g //生成静态的网页
hexo s //开启本地服务，可以在本地预览
Hexo d //上传生产的文件到配置的服务仓库（见_config.yml）
</code></pre><p> 官方文档：<a href="https://hexo.io/docs/" target="_blank" rel="external">https://hexo.io/docs/</a></p>
<h3 id="u540C_u65F6_u90E8_u7F72_u5230Coding_u548CGithub_u5E73_u53F0"><a href="#u540C_u65F6_u90E8_u7F72_u5230Coding_u548CGithub_u5E73_u53F0" class="headerlink" title="同时部署到Coding和Github平台"></a>同时部署到Coding和Github平台</h3><h4 id="Coding_Pages"><a href="#Coding_Pages" class="headerlink" title="Coding Pages"></a>Coding Pages</h4><p>Coding Pages 是一个免费的静态网页托管和演示服务。</p>
<p>在Coding创建一个和你用户相同项目用来部署你的Hexo 。<br>同时在代码选项开启的你的 pages服务。分支填写master(这里的分支要和部署时的对应)。<br>用户 Pages 可以通过{user_name}.coding.me 形式的 URL 直接访问。</p>
<p>官方文档 <a href="https://coding.net/help/doc/pages/index.html" target="_blank" rel="external">https://coding.net/help/doc/pages/index.html</a></p>
<h4 id="Github_pages"><a href="#Github_pages" class="headerlink" title="Github pages"></a>Github pages</h4><p>同样Gtihub也提供了一个 Pages免费服务。<br>同样你在Github创建一个名为username.github.io的仓库 。用来部署你的Hexo代码。</p>
<p>官方文档 <a href="https://pages.github.com/" target="_blank" rel="external">https://pages.github.com/</a></p>
<h4 id="config-yml_u914D_u7F6E"><a href="#config-yml_u914D_u7F6E" class="headerlink" title="_config.yml配置"></a>_config.yml配置</h4><p>同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下</p>
<pre><code>deploy:
  type: git
  repo:
    github: &lt;repository url&gt;,[branch]
    coding: &lt;repository url&gt;,[branch]
</code></pre><h3 id="Daocloud__u81EA_u52A8_u6784_u5EFA"><a href="#Daocloud__u81EA_u52A8_u6784_u5EFA" class="headerlink" title="Daocloud 自动构建"></a>Daocloud 自动构建</h3><p>项目主页：<a href="http://daocloud.io" target="_blank" rel="external">http://daocloud.io</a>   </p>
<p>注册账户，选择代码构建，创建应用。选择同步代码来源，我用的是coding平台。</p>
<p>在Blog项目的跟目录添加</p>
<h5 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h5><pre><code>FROM node:slim
MAINTAINER Janrone &lt;janrone@qq.com&gt;
# instal basic tool 
RUN apt-get update &amp;&amp; apt-get install -y git ssh-client ca-certificates --no-install-recommends &amp;&amp; rm -r /var/lib/apt/lists/*
# set time zone
RUN echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone &amp;&amp; dpkg-reconfigure -f noninteractive tzdata
RUN npm install
# install hexo
RUN npm install hexo-cli -g
# install hexo server
RUN npm install hexo-server
# set base dir
#RUN mkdir /hexo
# set home dir
#WORKDIR /hexo

EXPOSE 4000
#CMD [&quot;/bin/bash&quot;]
</code></pre><h5 id="daocloud-yml__u6CE8_u610Fyml_u6587_u4EF6_u7684_u683C_u3002"><a href="#daocloud-yml__u6CE8_u610Fyml_u6587_u4EF6_u7684_u683C_u3002" class="headerlink" title="daocloud.yml 注意yml文件的格。"></a>daocloud.yml 注意yml文件的格。</h5><pre><code>image: daocloud.io/janrone/blog:latest #daocloud/ci-node:0.12  
before_script:  
    - npm config set user 0
    - npm config set unsafe-perm true
    # 避免出现权限问题
    #- npm install hexo-cli -g
    # --registry=http://registry.npm.taobao.org 使用淘宝的npm源安装 更快捷
    #- npm install
    # - git clone https://github.com/luodaoyi/hexo-theme-next.git themes/next
    # 克隆主题到主题目录 这里的主题Git地址和目录替换成你自己的主题地址和目录
    - mkdir ~/.ssh
    # 新建私钥文件夹
    - mv .daocloud/id_rsa ~/.ssh/id_rsa
    # 移动私钥到私钥文件夹
    - mv .daocloud/ssh_config ~/.ssh/config
    # 移动ssh配置文件
    - chmod 600 ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/config
    # 赋予可读权限
    - eval $(ssh-agent)
    # 启用ssh-agent进程
    - ssh-add ~/.ssh/id_rsa
    # 添加密钥
    - rm -rf .daocloud
    # 删除项目里面的私钥存放目录
    - git config --global user.name &quot;janrone&quot;
    - git config --global user.email janrone@qq.com
    # 配置git
script:  
    - hexo clean
    - hexo g
    - hexo g
    # 生成html
    - hexo d
    # 发布html代码，根据你hexo的设置可以发布到多个平台
    - rm -rf ~/.ssh/
    # 删除私钥文件夹
</code></pre><p>大概说一下Dockefile文件和daocloud.yml文件。</p>
<p>Dockerfile是构建docker的配置文件，我选的node环境的基础镜像，并且在构建docker镜像的时候配置好Hexo环境。<br>所以在之后的持续集成的配置用可以省去hexo环境配置，缩短自动构建的时间。</p>
<p>daocloud.yml是代码持续集成的配置文件，直接使用之前我构建的docker镜像，daocloud.io/janrone/blog:latest ，这样每次集成的时候速度会快很多。<br>之后是配置ssh，我把私钥放到了项目的.daocloud文件下，并添加了ssh _config, </p>
<pre><code>StrictHostKeyChecking no
UserKnownHostsFile /dev/null
</code></pre><p>还有我创建Git SSH Key的时候没有没输入密码，这样解决了自动构建的时候提示要输入密码的问题。公钥记得加到coding 和 github 的deploye key里。</p>
<p>根据SSH私钥（private key）计算SSH公钥（public key）</p>
<pre><code>ssh-keygen -y -f ./id_rsa
</code></pre><p>不然肯定是发布不成功的。</p>
<p>接下来就是正常的 hexo g ，（生成静态文件）<br>，hexo d （发布静态文件）。我用hexo clean ，是清空了之前生成文件，防止再次生产部分文件是以前的问题。</p>
<h3 id="u57DF_u540D_u7ED1_u5B9A"><a href="#u57DF_u540D_u7ED1_u5B9A" class="headerlink" title="域名绑定"></a>域名绑定</h3><p>国内的走coding，海外的走github，只要配置2个CNAME就行。域名解析如下：<br>注意后边的的小点 </p>
<p><img src="/images/post/2016051501.png" alt=""></p>
<h4 id="ps_3A_u4E0D_u8981_u5FD8_u4E86_u5728_u9879_u76EE_u7684_u8DDF_u76EE_u5F55_u521B_u5EFA_u4E00_u4E2A_u540D_u5B57_u4E3ACNAME_u7684_u6587_u4EF6_uFF0C_u91CC_u8FB9_u5C31_u5199_u4E00_u884C_u4F60_u7684_u57DF_u540D_u5373_u53EF_u3002"><a href="#ps_3A_u4E0D_u8981_u5FD8_u4E86_u5728_u9879_u76EE_u7684_u8DDF_u76EE_u5F55_u521B_u5EFA_u4E00_u4E2A_u540D_u5B57_u4E3ACNAME_u7684_u6587_u4EF6_uFF0C_u91CC_u8FB9_u5C31_u5199_u4E00_u884C_u4F60_u7684_u57DF_u540D_u5373_u53EF_u3002" class="headerlink" title="ps:不要忘了在项目的跟目录创建一个名字为CNAME的文件，里边就写一行你的域名即可。"></a>ps:不要忘了在项目的跟目录创建一个名字为CNAME的文件，里边就写一行你的域名即可。</h4><p>不过要放在你的source目录，不然hexo g 重新生成静态文件的时候CNAME会消失。</p>
<p>绑定生效之后可以从这查询下域名解析的结果<br><a href="http://ping.chinaz.com/" target="_blank" rel="external">http://ping.chinaz.com/</a></p>
<h3 id="Hexo_u7CFB_u5217_u6587_u7AE0_uFF0C_u5199_u7684_u5F88_u4E0D_u9519_uFF0C_u5927_u5BB6_u53EF_u4EE5_u6309_u7740_u4E00_u6B65_u4E00_u6B65_u6765_u3002"><a href="#Hexo_u7CFB_u5217_u6587_u7AE0_uFF0C_u5199_u7684_u5F88_u4E0D_u9519_uFF0C_u5927_u5BB6_u53EF_u4EE5_u6309_u7740_u4E00_u6B65_u4E00_u6B65_u6765_u3002" class="headerlink" title="Hexo系列文章，写的很不错，大家可以按着一步一步来。"></a>Hexo系列文章，写的很不错，大家可以按着一步一步来。</h3><p><a href="http://tengj.top/categories/hexo/" target="_blank" rel="external">http://tengj.top/categories/hexo/</a>  </p>
<p>参考：hexo干货系列：（四）将hexo博客同时托管到github和coding<a href="http://tengj.top/2016/03/06/hexo%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97%EF%BC%9A%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B0%86hexo%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E6%89%98%E7%AE%A1%E5%88%B0github%E5%92%8Ccoding/" target="_blank" rel="external"></a></p>
<p>利用coding.和daocloud打造全自动发布的hexo博客<a href="http://luody.info/post/2016/06/21/coding-daocloud-hexo" target="_blank" rel="external"></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Hexo_u5B89_u88C5"><a href="#Hexo_u5B89_u88C5" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><pre><code>npm install -g hexo //安装完成]]>
    </summary>
    
      <category term="Daocloud" scheme="http://janrone.allone.top/tags/Daocloud/"/>
    
      <category term="Hexo" scheme="http://janrone.allone.top/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://janrone.allone.top/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac上Ruby和RubyGems安装使用说明]]></title>
    <link href="http://janrone.allone.top/2016/03/26/Mac%E4%B8%8ARuby%E5%92%8CRubyGems%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://janrone.allone.top/2016/03/26/Mac上Ruby和RubyGems安装使用说明/</id>
    <published>2016-03-26T07:52:33.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<h4 id="u5B89_u88C5_RVM"><a href="#u5B89_u88C5_RVM" class="headerlink" title="安装 RVM"></a>安装 RVM</h4><p>RVM:Ruby Version Manager,Ruby版本管理器，包括Ruby的版本管理和Gem库管理(gemset)</p>
<p>　　　　$ curl -L <a href="https://get.rvm.io" target="_blank" rel="external">https://get.rvm.io</a> | bash -s stable
　　　　</p>
<h4 id="u7136_u540E_uFF0C_u8F7D_u5165_RVM__u73AF_u5883"><a href="#u7136_u540E_uFF0C_u8F7D_u5165_RVM__u73AF_u5883" class="headerlink" title="然后，载入 RVM 环境"></a>然后，载入 RVM 环境</h4><p>　　　　$ source ~/.rvm/scripts/rvm</p>
<h4 id="u67E5_u770B_u5F53_u524Druby_u7248_u672C"><a href="#u67E5_u770B_u5F53_u524Druby_u7248_u672C" class="headerlink" title="查看当前ruby版本"></a>查看当前ruby版本</h4><pre><code>$ ruby -v  
ruby 1.8.7  
#列出已知的ruby版本  
$ rvm list known  
#安装ruby 1.9.3  
$ rvm install 1.9.3 

步骤3 － 设置 Ruby 版本
</code></pre><p>RVM 装好以后，需要执行下面的命令将指定版本的 Ruby 设置为系统默认版本</p>
<p>　　　　$ rvm 2.0.0 –default<br>　　　　<br>　　　　<br>有可能是因为Ruby的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，网上的一种解决方案是将远替换成淘宝的，替换方式如下：</p>
<pre><code>$ gem source -r https://rubygems.org/
$ gem source -a https://ruby.taobao.org

$ gem source -r https://rubygems.org/
https://rubygems.org/ removed from sources
$ gem source -a https://ruby.taobao.org
https://ruby.taobao.org added to sources
</code></pre><p>要想验证是否替换成功了，可以执行：</p>
<pre><code>$ gem sources -l  
正常的输出结果：
$ gem sources -l
*** CURRENT SOURCES ***
https://ruby.taobao.org
</code></pre><p>这里就表示已经把Ruby环境成功的安装到了Mac 上了。</p>
<h3 id="ERORR"><a href="#ERORR" class="headerlink" title="ERORR"></a>ERORR</h3><p>1,dependency.rb:307:in `to_spec’ </p>
<pre><code>First verify ruby is correctly installed:

$ ruby -e &apos;puts &quot;Testing Ruby&quot;&apos;
From the error, it seems like you haven&apos;t installed the rhc gem. First check if it&apos;s installed:

$ which rhc
If rhc isn&apos;t installed, try this:

$ sudo gem install rhc
$ rhc setup
And try again. 
</code></pre><p>参考<br><a href="https://rubygems.org/" target="_blank" rel="external">https://rubygems.org/</a>    </p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u5B89_u88C5_RVM"><a href="#u5B89_u88C5_RVM" class="headerlink" title="安装 RVM"></a>安装 RVM</h4><p>RVM:Ruby Version Manager,Ruby版本管理器，包]]>
    </summary>
    
      <category term="Mac" scheme="http://janrone.allone.top/categories/Mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac下安装及配置 ProxyChains-NG 实现终端下代理]]></title>
    <link href="http://janrone.allone.top/2016/03/26/Mac%E4%B8%8B%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-ProxyChains-NG-%E5%AE%9E%E7%8E%B0%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%BB%A3%E7%90%86/"/>
    <id>http://janrone.allone.top/2016/03/26/Mac下安装及配置-ProxyChains-NG-实现终端下代理/</id>
    <published>2016-03-26T05:30:42.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<h3 id="ProxyChains-NG"><a href="#ProxyChains-NG" class="headerlink" title="ProxyChains-NG"></a>ProxyChains-NG</h3><p>项目主页：<a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="external">https://github.com/rofl0r/proxychains-ng</a><br>官方说明：</p>
<p>proxychains ng (new generation) - a preloader which hooks calls to sockets in dynamically linked programs and redirects it through one or more socks/http proxies. continuation of the unmaintained proxychains project.</p>
<h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><p>使用 Homebrew 安装</p>
<p>brew install proxychains-ng</p>
<h3 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h3><p>编辑配置文件</p>
<pre><code>sudo vim /usr/local/Cellar/proxychains-ng/4.10/etc/proxychains.conf
</code></pre><p>在 [ProxyList] 下面（也就是末尾）加入代理类型，代理地址和端口<br>注释掉原来的代理并添加</p>
<pre><code>socks5  127.0.0.1 1080
</code></pre><p>ps: 默认的socks4 127.0.0.1 9095是tor代理，而socks5 127.0.0.1 1080是shadowsocks的代理。</p>
<p>如果所在的网络很复杂，可能需要在配置文件中启用<br>dynamic_chain - 按照列表中出现的代理服务器的先后顺序组成一条链，如果有代理服务器失效，则自动将其排除，但至少要有一个是有效的，然后在 [ProxyList] 下添加多个代理。</p>
<p>默认是：<br>strict_chain - 按照后面列表中出现的代理服务器的先后顺序组成一条链，要求所有的代理服务器都是有效的。</p>
<p>ps: 4.10 是proxychains-ng的版本好，具体参看自己的版本。</p>
<h3 id="u7528_u6CD5_uFF1A"><a href="#u7528_u6CD5_uFF1A" class="headerlink" title="用法："></a>用法：</h3><pre><code>proxychains4 curl twitter.com
</code></pre><h3 id="u8865_u5145alias"><a href="#u8865_u5145alias" class="headerlink" title="补充alias"></a>补充alias</h3><pre><code>vim ~/.bash_profile
插入

alias gfw=&apos;proxychains4&apos;
alias sudogfw=&apos;sudo proxychains4&apos;
使~/.bash_profile生效

source ~/.bash_profile
</code></pre><p>配置示例</p>
<p>strict_chain<br>proxy_dns<br>remote_dns_subnet 224<br>tcp_read_time_out 15000<br>tcp_connect_time_out 8000<br>localnet 127.0.0.0/255.0.0.0</p>
<p>[ProxyList]<br>socks5 127.0.0.1 1080    </p>
<h3 id="Mac_OS_10-11__u6062_u590D_u6A21_u5F0F_u4E0B__u5173_u95ED_SIP"><a href="#Mac_OS_10-11__u6062_u590D_u6A21_u5F0F_u4E0B__u5173_u95ED_SIP" class="headerlink" title="Mac OS 10.11  恢复模式下  关闭 SIP"></a>Mac OS 10.11  恢复模式下  关闭 SIP</h3><p>Command ＋ R 进入恢复模式，选择Terminal 执行</p>
<pre><code>csrutil enable --without debug
</code></pre><p>Apple Internal: enabled<br>Kext Signing: enabled<br>Filesystem Protections: enabled<br>Debugging Restrictions: enabled<br>DTrace Restrictions: enabled<br>NVRAM Protections: enabled </p>
<p>disable 是把 5 个都关了。。。 </p>
<p>目测 proxychains 之类的需要加入 LD_PRELOAD 进行动态 HOOK<br>debug 那个就是保护了关键路径上的 bin 不被劫持 </p>
<p>其他都是字面意思 </p>
<p>保护的只有 rootless.conf 定义的目录文件</p>
<p>参考：  </p>
<p><a href="https://eliyar.biz/code/proxy-for-mac-terminal/" target="_blank" rel="external">https://eliyar.biz/code/proxy-for-mac-terminal/</a></p>
<p><a href="http://yanghui.name/blog/2015/07/19/make-all-command-through-proxy/" target="_blank" rel="external">http://yanghui.name/blog/2015/07/19/make-all-command-through-proxy/</a></p>
<p><a href="https://www.v2ex.com/t/225043" target="_blank" rel="external">https://www.v2ex.com/t/225043</a>    </p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="ProxyChains-NG"><a href="#ProxyChains-NG" class="headerlink" title="ProxyChains-NG"></a>ProxyChains-NG</h3><p>项目主页：<a href="https://]]>
    </summary>
    
      <category term="Mac" scheme="http://janrone.allone.top/tags/Mac/"/>
    
      <category term="Mac" scheme="http://janrone.allone.top/categories/Mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Studio 快捷键]]></title>
    <link href="http://janrone.allone.top/2016/03/23/Android-Studio-%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://janrone.allone.top/2016/03/23/Android-Studio-快捷键/</id>
    <published>2016-03-23T05:36:00.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<h3 id="Android_Studio__u5FEB_u6377_u952E"><a href="#Android_Studio__u5FEB_u6377_u952E" class="headerlink" title="Android Studio 快捷键"></a>Android Studio 快捷键</h3><p>常用的AS中的操作 (⌘:command, ⌃:ctrl, ⇧:shift, ⌥:alt/option, ⏎:enter/return )</p>
<p>）保存，⌘s    这个在AS中其实是自动保存的。即使关闭Tab页后，再次打开，⌘z还是可以撤销编辑的</p>
<p>·）getter、setter、toString、constructor…       ⌘n</p>
<p>·）类层级：⌃h </p>
<p>·）在当前project(一个project可以含多个moudle)中搜索class：⌘o</p>
<pre><code>再按一次⌘o(会发现，右上角的选项勾选了)，搜索结果可包含非project中的class，如external libraries中的android.jar里的class
可以在搜索文本后跟:lineNumber   从而定位到某行
</code></pre><p>·）在当前project中搜索file(包含上面的class结果)：⌘⇧o</p>
<pre><code>再按一次⌘⇧o，搜索结果可包含非project中的flie，如external libraries中的res里的file
可以在搜索文本后跟:lineNumber   从而定位到某行，如 输入文本：mainacti:20  这时就会定位到    MainActivity的20行
</code></pre><p>·）在当前project中搜索属性(成员和静态，不论是否私有) ⌘⌥o  </p>
<pre><code>再按一次，搜索结果可包含非project中的class
</code></pre><p>·）如eclipse中的⌘1的action(即win-eclipse上的ctrl+1)：⌥⏎    quick fix</p>
<pre><code>即alter+enter (需要光标移动到分号之前，可以在代码内容里，当该代码行下标红时)
</code></pre><p>·）如eclipse中的⌘⇧2+L(自动声明变量) : ⌘⌥v</p>
<p>·）如eclipse中的⌘o(查看当前类成员):     ⌘F12， </p>
<pre><code>显示内部成员
⌘i 显示/取消息匿名类
⌘f12 显示继承自父类、父接口的成员
</code></pre><p>·）选择能重写(override)或实现(implement)的方法 ：⌃o<br>·）如eclipse中的⌘⇧G，查找方法在哪被使用：⌥F7<br>·）定位到属性、方法、类等它们的声明：F4<br>·）查看父类的同名方法：⌘U<br>·）光标在调用接口方法的方法名中，查看接口方法实现类：⌘⌥B 或 ⌘⌥click<br>·）Surround With: if、while、try-catch、synchronized 等等：⌘⌥T<br>·）重构面板：⌃T<br>·）Extract Method 抽取成方法：⌘⌥M<br>·）Extract Field 抽取为成员属性：⌘⌥F<br>·）Extract Parameter 将内部变量抽取成方法的参数：⌘⌥P<br>·）去除无效引用： ^⌥O<br>·）整理代码且能去除无效引用：⌘⌥L<br>·）open recent file 历史打开过的文件： ⌘E<br>·）find usages 查找使用情况：⌘⌥⇧F7<br>·）查找与替换：⌘F，⌘R     </p>
<pre><code>在查找后，使用⌘G 定位到下一个text
find in path与replace in path：⌘⇧F，⌘⇧R
</code></pre><p>·）大小写转换：⌘⇧U<br>·）重命名：⇧F6<br>·）光标换行：⌘⇧⏎<br>·）在当前行上添加一行，光标定位到行首：⌘⌥⏎<br>·）复制整行：⌘D<br>·）删除整行：⌘delete<br>·）内容行上下移动，不会出方法体；或光标在方法体外且在方法行上时，移动整个方法：⇧⌘↑|↓<br>·）上下移动光标所在行：⌥⇧↑|↓<br>·）剪切，若无选中文本时会剪切整行：⌘X<br>·）查看doc/文档注释：F1<br>·）定位到未使用的声明 F2<br>·）⌘j ：快捷代码片段</p>
<pre><code>  psf =&gt; public static final 
  ifn =&gt; if (a == null)
  inn=&gt; if (a != null)
 fori=&gt; for(int i = 0; i &lt; .....)
 I(大写i)=&gt; for(Object o : ) 
..... 其它 
</code></pre><p>最后说下代码提示：</p>
<pre><code>在AS中，默认在你输入的时候就自动提示了，想手动提示看一下，
    参数要填哪些类型，这个还真不知道，好像只能F1查看doc注释了。
而提示符合前缀的变量、方法、类型等时，使用 ⌘Space
</code></pre><h3 id="Action_Mac_OSX_Win/Linux"><a href="#Action_Mac_OSX_Win/Linux" class="headerlink" title="Action    Mac OSX     Win/Linux"></a>Action    Mac OSX     Win/Linux</h3><p>注释代码(//)    Cmd + /    Ctrl + /<br>注释代码(/**/)    Cmd + Option + /    Ctrl + Alt + /<br>格式化代码    Cmd + Option + L    Ctrl + Alt + L<br>清除无效包引用    Option + Control + O    Alt + Ctrl + O<br>查找    Cmd + F    Ctrl + F<br>查找+替换    Cmd + R    Ctrl + R<br>上下移动代码    Option + Shift + Up/Down    Alt + Shift + Up/Down<br>删除行    Cmd + Delete    Ctrl + Y<br>扩大缩小选中范围    Option + Up/Down    Ctrl + W/Ctrl + Shift + W<br>快捷生成结构体    Cmd + Option + T    Ctrl + Alt + T<br>快捷覆写方法    Ctrl + O    Ctrl + O<br>快捷定位到行首/尾    Cmd + Left/Right    Ctrl + Left/Right<br>折叠展开代码块    Cmd + Plus,Minus    Ctrl + Plus/Minus<br>折叠展开全部代码块    Cmd + Shift + Plus,Minus    Ctrl + Shift + Plus,Minus<br>文件方法结构    Cmd + F12    Ctrl + F12<br>查找调用的位置    Ctrl + Option + H    Ctrl + Alt + H<br>大小写转换    Cmd + Shift + U    Ctrl + Shift + U</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Android_Studio__u5FEB_u6377_u952E"><a href="#Android_Studio__u5FEB_u6377_u952E" class="headerlink" title="Android Studio 快捷键"></a>An]]>
    </summary>
    
      <category term="Android" scheme="http://janrone.allone.top/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读写给大家看的设计书]]></title>
    <link href="http://janrone.allone.top/2016/01/13/%E8%AF%BB%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6/"/>
    <id>http://janrone.allone.top/2016/01/13/读写给大家看的设计书/</id>
    <published>2016-01-13T07:20:09.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>有些人需要设计页面，但完全没有设计背景，或者在设计方面没有经过正规培训，本书正是为这些人所写的。 </p>
<h8 style="text-align:right">From: 威谦斯 (Robin Williams). “写给大家看的设计书(第3版).”<br></h8></blockquote>
<h3 id="u7B2C_u4E00_u90E8_u5206"><a href="#u7B2C_u4E00_u90E8_u5206" class="headerlink" title="第一部分"></a>第一部分</h3><ol>
<li><p>4大设计原则 </p>
<p>  <img src="/images/post/shejishu/0001.jpg" alt=""></p>
<p> “对比（Contrast）”“重复（Repetition）”“对齐（Alignment）”“亲密性（Proximity）”</p>
</li>
</ol>
<p> “亲密性原则是指：将相关的项组织在一起，移动这些项，使它们的物理位置相互靠近，这样一来，相关的项将被看作凝聚为一体的一个组，而不再是一堆彼此无关的片段。”</p>
<p> “对齐原则是指：任何元素都不能在页面上随意安放。每一项都应当与页面上的某个内容存在某种视觉联系。”</p>
<ol>
<li></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote class="blockquote-center"><p>有些人需要设计页面，但完全没有设计背景，或者在设计方面没有经过正规培训，本书正是为这些人所写的。 </p>
<h8 style="text-align:right">From: 威谦斯 (Robin]]>
    </summary>
    
      <category term="设计" scheme="http://janrone.allone.top/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="设计" scheme="http://janrone.allone.top/categories/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[时间与艺术——怀表]]></title>
    <link href="http://janrone.allone.top/2016/01/07/%E6%97%B6%E9%97%B4%E4%B8%8E%E8%89%BA%E6%9C%AF-%E6%80%80%E8%A1%A8/"/>
    <id>http://janrone.allone.top/2016/01/07/时间与艺术-怀表/</id>
    <published>2016-01-07T03:29:19.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<h4 id="1-__u79D1_u666E_Gold_Filled__2C_Gold_Plated__u4E0E_14K_u91D1"><a href="#1-__u79D1_u666E_Gold_Filled__2C_Gold_Plated__u4E0E_14K_u91D1" class="headerlink" title="1. 科普 Gold Filled , Gold Plated  与 14K金"></a>1. 科普 Gold Filled , Gold Plated  与 14K金</h4><p>Gold Filled<br>   指的是将10Kt以上品位的金层用机械以高温高压处理的方式压延附着在金属基材（铜材等）上，也就是通常说的贴金。</p>
<p>   美国联邦规定中，”Gold Filled”是指那些金层的重量在包括金属基材在内的总重量中占到1/20以上的制品。<br>   粗略的计算大约应该是25微米左右的厚度<br>   金制品一般表面刻有”GF”，”Gold Filled”</p>
<p>   而在英国，两面贴金或全面贴金被称为”Filled”，单面或部分贴金是”Rolled”，刻印为”GR”，”Gold Rolled”。</p>
<p>Gold Plated<br>   指的是采用电解法等方法使金层以微米单位附着在金属基材上，也就是通常说的镀金，但是准确地说，象这种薄薄的镀层应该称为”Flash”。</p>
<p>   美国联邦规定中，10Kt以上的金镀层在0.5微米（约20/1000000厘米）以上的制品可标示为”GP”或”Gold Plated”。</p>
<p>   还有，”GEP”，”Gold ElectroPlated” 指的是用电加工方法，金镀层约0.175微米的制品。<br> “Heavy Gold ElectroPlated”  指的是金镀层为2.5微米的制品。</p>
<p> 14K金<br>     K是确定金饰品中黄金含量的单位，英语为Karat，简称为“K”。14K黄金表示首饰中黄金含量为58.5%。</p>
<pre><code>K金制规定K金分为24种，24k金为纯黄金，理论值为100%；相应地，1K=1/24，14K黄金的黄金含量计算公式如下：
</code></pre><p>14k=100%/24*14=58.333%（585‰）。为方便标识，国际上一般把14K金的黄金含量约定为58.5%。<br>14k黄金的出现，跟黄金本身的特点有关，是人们为了满足首饰的耐用性和多样性的需求，在实践中探索出来的：“黄金有一个特点是自身比较柔软，所以难以镶嵌制成比较精美的首饰款式，尤其是镶嵌珍珠、宝石和翡翠等珍贵宝石时，容易丢失。古人发现在纯金中加入少量的银、铜、锌等金属就可以增加黄金的硬度与韧性，进而制作出各式各样的金饰。”</p>
<h4 id="2-__u8868_u5916_u89C2"><a href="#2-__u8868_u5916_u89C2" class="headerlink" title="2. 表外观"></a>2. 表外观</h4><p>主要分没表盖（open-face）和有表盖（hunter），有表盖里面还分双表盖（double-hunter），半开（half-hunter），还有可不可以透视（skeleton）等等</p>
<h4 id="3-__u54C1_u724C"><a href="#3-__u54C1_u724C" class="headerlink" title="3. 品牌"></a>3. 品牌</h4><p>Hamilton（汉密尔顿）、Elgin（爱尔近）、Waltham（华生）、Hampton（汉普顿）、Illinois（伊利诺斯）、Westclox（西部钟表公司）等众多至今为人熟悉或似曾熟悉的品牌纷纷登上历史舞台，至此美国已成为制表业的世界第一大国。</p>
<h3 id="4-__u67E5_u8BE2_u7F51_u5740"><a href="#4-__u67E5_u8BE2_u7F51_u5740" class="headerlink" title="4. 查询网址"></a>4. 查询网址</h3><p>英国银质怀表查询 <a href="http://www.silvermakersmarks.co.uk/index.htm" target="_blank" rel="external">http://www.silvermakersmarks.co.uk/index.htm</a></p>
<p>针对美国怀表生产日期查询的网址包括了华生、波尔、汉米尔顿、汉普顿、爱尔近、伊利诺斯、Southbend和Rockford等。<br><a href="https://pocketwatchdatabase.com/" target="_blank" rel="external">https://pocketwatchdatabase.com/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="1-__u79D1_u666E_Gold_Filled__2C_Gold_Plated__u4E0E_14K_u91D1"><a href="#1-__u79D1_u666E_Gold_Filled__2C_Gold_Plated__u4E0E_14K_u91D1]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java IO中几个主要类介绍和使用]]></title>
    <link href="http://janrone.allone.top/2016/01/05/Java-IO-%E5%87%A0%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://janrone.allone.top/2016/01/05/Java-IO-几个主要类的使用/</id>
    <published>2016-01-05T02:55:41.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<h4 id="1-_I/O_u6D41_u53EF_u4EE5_u6709_u4E09_u79CD_u5206_u7C7B_u65B9_u6CD5"><a href="#1-_I/O_u6D41_u53EF_u4EE5_u6709_u4E09_u79CD_u5206_u7C7B_u65B9_u6CD5" class="headerlink" title="1. I/O流可以有三种分类方法."></a>1. I/O流可以有三种分类方法.</h4><pre><code>第一, 输入流,输出流 .
第二, 字节流,字符流 . 
第三, 节点流(真正直接处理数据的) ,处理流(装饰加工节点流的) .
</code></pre><h4 id="2-__u5B57_u8282_u6D41"><a href="#2-__u5B57_u8282_u6D41" class="headerlink" title="2. 字节流"></a>2. 字节流</h4><pre><code>抽象类 &lt;– 面向字节的文件流 .  
InputStream &lt;– FileInputStream  
OutputStream &lt;– FileOutputStream  

常用方法 
InputStream  int read(byte [] c,int off, int len)  
OutputStream voidwrite(byte [] c,int off, int len) .
</code></pre><h4 id="3-__u5B57_u7B26_u6D41"><a href="#3-__u5B57_u7B26_u6D41" class="headerlink" title="3. 字符流"></a>3. 字符流</h4><pre><code>抽象类 &lt;– 面向字符文件流 .
Reader &lt;– FileReader 
Writer &lt;— FileWriter 

常用方法 
FileReader int read(char [] c,int off, int len)   
FileWriter voidwrite(char [] c,int off, int len) .
</code></pre><h4 id="4-__u8282_u70B9_u6D41_u548C_u5904_u7406_u6D41"><a href="#4-__u8282_u70B9_u6D41_u548C_u5904_u7406_u6D41" class="headerlink" title="4. 节点流和处理流"></a>4. 节点流和处理流</h4><pre><code>类
BufferdReader 可以称作字符、输入、处理流 .

方法
String readLine()

BufferdReader构造函数接受的是 Reader 类型的参数
</code></pre><a id="more"></a>
<h4 id="4-_Java_u4E2Dio_u7C7B_u662F_u5178_u578B_u7684_u88C5_u9970_u8005_u6A21_u5F0F"><a href="#4-_Java_u4E2Dio_u7C7B_u662F_u5178_u578B_u7684_u88C5_u9970_u8005_u6A21_u5F0F" class="headerlink" title="4. Java中io类是典型的装饰者模式"></a>4. Java中io类是典型的装饰者模式</h4><h4 id="5-__u793A_u4F8B"><a href="#5-__u793A_u4F8B" class="headerlink" title="5. 示例"></a>5. 示例</h4><pre><code>import java.io.*;
public class Filerw{
    public static void main (String args[]){
        Filerw filerw=new Filerw();
        //filerw.readAndWrite();
        filerw.bufferReader();
    }
        /**
        *   1.使用输入输出流操作文件
        */
        public void readAndWriteStream(){
            FileInputStream inStream=null;
            FileOutputStream outStream=null;
            try{
                //生成一个输入流的对象  
                inStream=new FileInputStream(“e:/javapro/FileDemo/from.txt”);  
                //生成一个输入流的对象  
                outStream=new FileOutputStream(“e:/javapro/FileDemo/to.txt”);  
                byte[] buffer=new byte[1024];
                int len=0;
                //读取文件
                len=inStream.read(buffer,0,buffer.length);
                for(int i=0; i&lt;len; i++){
                    System.out.print(buffer[i]);
                }
                //写入到文件
                outStream.write(buffer,0,len);
            }catch (Exception  e){
                System.out.print(e);
            }finally{
                try{
                    inStream.close();
                    outStream.close();
                }catch (Exception e){
                    System.out.print(e);
                }
            }
        }
        /**
        *   2.使用字节流操作文件
        */
        public void readAndWrite(){
            FileReader reader=null;
            FileWriter writer=null;
            try{
                //生成一个字符输入流的对象  
                reader=new FileReader(“e:/javapro/FileDemo/from.txt”);  
                //生成一个字符输入流的对象  
                writer=new FileWriter(“e:/javapro/FileDemo/to.txt”);  
                char[] buffer=new char[1024];
                int len=0;
                //读取文件
                len=reader.read(buffer,0,buffer.length);
                for(int i=0; i&lt;len; i++){
                    System.out.print(buffer[i]);
                }
                //写入到文件
                writer.write(buffer,0,len);
            }catch (Exception  e){
                System.out.print(e);
            }finally{
                try{
                    reader.close();
                    writer.close();
                }catch (Exception e){
                    System.out.print(e);
                }
            }
        }
        /**
        *   3.使用节点流和处理流操作文件
        */
        public void bufferReader(){
            FileReader reader=null;  
            BufferedReader bufferedReader=null;  
            try{
                reader=new FileReader(“e:/javapro/FileDemo/fromlinetext.txt”);
                bufferedReader=new BufferedReader(reader);
                String line=null;
                while((line=bufferedReader.readLine())!=null){  
                    //line=bufferedReader.readLine();  
                    System.out.println(line);  
                }
            }catch (Exception e){
                System.out.print(e);
            }finally{
                try{
                    reader.close();
                    bufferedReader.close();
                }catch (Exception e){
                    System.out.print(e);
                }
            }
        }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="1-_I/O_u6D41_u53EF_u4EE5_u6709_u4E09_u79CD_u5206_u7C7B_u65B9_u6CD5"><a href="#1-_I/O_u6D41_u53EF_u4EE5_u6709_u4E09_u79CD_u5206_u7C7B_u65B9_u6CD5" class="headerlink" title="1. I/O流可以有三种分类方法."></a>1. I/O流可以有三种分类方法.</h4><pre><code>第一, 输入流,输出流 .
第二, 字节流,字符流 . 
第三, 节点流(真正直接处理数据的) ,处理流(装饰加工节点流的) .
</code></pre><h4 id="2-__u5B57_u8282_u6D41"><a href="#2-__u5B57_u8282_u6D41" class="headerlink" title="2. 字节流"></a>2. 字节流</h4><pre><code>抽象类 &lt;– 面向字节的文件流 .  
InputStream &lt;– FileInputStream  
OutputStream &lt;– FileOutputStream  

常用方法 
InputStream  int read(byte [] c,int off, int len)  
OutputStream voidwrite(byte [] c,int off, int len) .
</code></pre><h4 id="3-__u5B57_u7B26_u6D41"><a href="#3-__u5B57_u7B26_u6D41" class="headerlink" title="3. 字符流"></a>3. 字符流</h4><pre><code>抽象类 &lt;– 面向字符文件流 .
Reader &lt;– FileReader 
Writer &lt;— FileWriter 

常用方法 
FileReader int read(char [] c,int off, int len)   
FileWriter voidwrite(char [] c,int off, int len) .
</code></pre><h4 id="4-__u8282_u70B9_u6D41_u548C_u5904_u7406_u6D41"><a href="#4-__u8282_u70B9_u6D41_u548C_u5904_u7406_u6D41" class="headerlink" title="4. 节点流和处理流"></a>4. 节点流和处理流</h4><pre><code>类
BufferdReader 可以称作字符、输入、处理流 .

方法
String readLine()

BufferdReader构造函数接受的是 Reader 类型的参数
</code></pre>]]>
    
    </summary>
    
      <category term="java" scheme="http://janrone.allone.top/tags/java/"/>
    
      <category term="Java" scheme="http://janrone.allone.top/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Studio 开发遇到错误和解决方法集合]]></title>
    <link href="http://janrone.allone.top/2015/12/29/Android-Studio-%E5%BC%80%E5%8F%91Android%E9%81%87%E5%88%B0%E9%94%99%E8%AF%AF%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88/"/>
    <id>http://janrone.allone.top/2015/12/29/Android-Studio-开发Android遇到错误和解决方法集合/</id>
    <published>2015-12-29T11:28:59.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<h3 id="1_-Duplicate_files_copied_in_APK_META-INF/LICENSE-txt"><a href="#1_-Duplicate_files_copied_in_APK_META-INF/LICENSE-txt" class="headerlink" title="1 .Duplicate files copied in APK META-INF/LICENSE.txt"></a>1 .Duplicate files copied in APK META-INF/LICENSE.txt</h3><pre><code>android {
    packagingOptions {
    exclude &apos;META-INF/LICENSE.txt&apos;
    }
}
My logcat: log Execution failed for task &apos;:Prog:packageDebug&apos;.

Duplicate files copied in APK META-INF/LICENSE.txt File 1: /home/scijoker/AndroidStudioProjects/ProgProject/Prog/libs/httpclient-4.1.1.jar File 2: /home/scijoker/AndroidStudioProjects/ProgProject/Prog/libs/httpclient-4.1.1.jar
</code></pre><h3 id="u89E3_u51B3_u65B9_u6CD5"><a href="#u89E3_u51B3_u65B9_u6CD5" class="headerlink" title="解决方法"></a>解决方法</h3><pre><code>android {  
    packagingOptions {  
        exclude &apos;META-INF/DEPENDENCIES.txt&apos;  
        exclude &apos;META-INF/LICENSE.txt&apos;  
        exclude &apos;META-INF/NOTICE.txt&apos;  
        exclude &apos;META-INF/NOTICE&apos;  
        exclude &apos;META-INF/LICENSE&apos;  
        exclude &apos;META-INF/DEPENDENCIES&apos;  
        exclude &apos;META-INF/notice.txt&apos;  
        exclude &apos;META-INF/license.txt&apos;  
        exclude &apos;META-INF/dependencies.txt&apos;  
        exclude &apos;META-INF/LGPL2.1&apos;  
    }  
}  
</code></pre><h3 id="2_-empty_throwable_the_apk_file_does_not_exist_on_disk"><a href="#2_-empty_throwable_the_apk_file_does_not_exist_on_disk" class="headerlink" title="2 .empty throwable the apk file does not exist on disk"></a>2 .empty throwable the apk file does not exist on disk</h3><p>每次运行代码有修改 app无修改， clean 之后 ，提示找不到上个版本的apk ，疑似缓存问题，按照下图操作后正常</p>
<p> <img src="/images/post/error002.png" alt=""></p>
<h4 id="u9644__u6E05_u9664Android_Studio__u7F13_u5B58"><a href="#u9644__u6E05_u9664Android_Studio__u7F13_u5B58" class="headerlink" title="附 清除Android Studio 缓存"></a>附 清除Android Studio 缓存</h4><pre><code>rm -rfv ~/Library/Caches/AndroidStudio*    
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1_-Duplicate_files_copied_in_APK_META-INF/LICENSE-txt"><a href="#1_-Duplicate_files_copied_in_APK_META-INF/LICENSE-txt" class="heade]]>
    </summary>
    
      <category term="Android" scheme="http://janrone.allone.top/tags/Android/"/>
    
      <category term="Android Studio" scheme="http://janrone.allone.top/tags/Android-Studio/"/>
    
      <category term="Android" scheme="http://janrone.allone.top/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[查看apk签名 和 keystore 的信息]]></title>
    <link href="http://janrone.allone.top/2015/12/29/%E6%9F%A5%E7%9C%8Bapk%E7%AD%BE%E5%90%8D-%E5%92%8C-keystore-%E7%9A%84%E4%BF%A1%E6%81%AF/"/>
    <id>http://janrone.allone.top/2015/12/29/查看apk签名-和-keystore-的信息/</id>
    <published>2015-12-29T09:20:28.000Z</published>
    <updated>2020-01-16T02:52:59.534Z</updated>
    <content type="html"><![CDATA[<h3 id="1_u3001_u67E5_u770B_keystore"><a href="#1_u3001_u67E5_u770B_keystore" class="headerlink" title="1、查看 keystore"></a>1、查看 keystore</h3><p>$ keytool -list -v -keystore debug.keystore </p>
<pre><code>$ keytool -list -v -keystore debug.keystore 
Enter keystore password:  

*****************  WARNING WARNING WARNING  *****************
* The integrity of the information stored in your keystore  *
* has NOT been verified!  In order to verify its integrity, *
* you must provide your keystore password.                  *
*****************  WARNING WARNING WARNING  *****************

Keystore type: JKS
Keystore provider: SUN

Your keystore contains 1 entry

Alias name: androiddebugkey
Creation date: Apr 8, 2015
Entry type: PrivateKeyEntry
Certificate chain length: 1
Certificate[1]:
Owner: CN=Android Debug, O=Android, C=US
Issuer: CN=Android Debug, O=Android, C=US
Serial number: 509aeb88
Valid from: Wed Apr 08 20:48:48 CST 2015 until: Fri Mar 31 20:48:48 CST 2045
Certificate fingerprints:
     MD5:  38:43:E1:B6:AB:F2:7F:80:93:CD:E5:EF:75:B9:A5:6C
     SHA1: 9D:53:DB:6C:DA:D4:08:B3:D4:A6:E5:26:17:BD:80:FA:5A:E4:4F:AB
     SHA256: D5:FF:04:4A:A2:F8:A4:EA:2A:44:53:28:0C:20:16:45:E8:71:AC:B1:74:76:F6:B4:01:90:86:83:73:E0:B0:8A
     Signature algorithm name: SHA256withRSA
     Version: 3

Extensions: 

#1: ObjectId: 2.5.29.14 Criticality=false
SubjectKeyIdentifier [
KeyIdentifier [
0000: B2 FF B2 0D 9C 54 BA BA   A2 EF E3 BA E2 47 90 7F  .....T.......G..
0010: 17 8A 35 A8                                        ..5.
]
]

*******************************************
</code></pre><hr>
<h3 id="2_u3001_u67E5_u770B_u4E09_u65B9_u5E94_u7528_u6216_u662F_u7CFB_u7EDF_u5E94_u7528_u7B7E_u540D"><a href="#2_u3001_u67E5_u770B_u4E09_u65B9_u5E94_u7528_u6216_u662F_u7CFB_u7EDF_u5E94_u7528_u7B7E_u540D" class="headerlink" title="2、查看三方应用或是系统应用签名"></a>2、查看三方应用或是系统应用签名</h3><p>打开待查看的apk，将其中META-INF文件夹解压出来，得到其中的CERT.RSA文件   </p>
<p>$ keytool -printcert -file META-INF/CERT.RSA</p>
<pre><code>打开待查看的apk，将其中META-INF文件夹解压出来，得到其中的CERT.RSA文件
$ keytool -printcert -file META-INF/CERT.RSA

Owner: CN=Android Debug, O=Android, C=US


Issuer: CN=Android Debug, O=Android, C=US


Serial number: 514ab2e1


Valid from: Thu Mar 21 15:12:33 CST 2013 until: Sat Mar 14 15:12:33 CST 2043


Certificate fingerprints:


MD5:  E0:F4:90:EE:CD:77:17:0E:B8:C4:AC:64:B2:F6:FC:83


SHA1: 7F:E5:11:D8:37:4F:DA:D7:75:EA:A5:8C:47:06:85:95:6D:1D:3F:2B


Signature algorithm name: SHA1withRSA


Version: 3
</code></pre><h3 id="3_u3001_u7ED9_u7A7A_u767D_u5305_u7B7E_u540D__uFF08_u6CE8_u610F_alias__u503C_uFF09"><a href="#3_u3001_u7ED9_u7A7A_u767D_u5305_u7B7E_u540D__uFF08_u6CE8_u610F_alias__u503C_uFF09" class="headerlink" title="3、给空白包签名 （注意 alias 值）"></a>3、给空白包签名 （注意 alias 值）</h3><p>jarsigner -verbose -keystore [keystorePath] -signedjar [apkOut] [apkIn] [alias]</p>
<p>jarsigner命令格式：-verbose输出详细信息 -keystore密钥库位置 -signedjar要生成的文件 要签名的文件 密钥库文件<br>keystorePath参数代表keyStore的绝对路径，如D:\keystore<br>apkOut参数代表签名后的apk路径，如D:\signed.apk<br>apkin参数代表在腾讯应用中心下载的未签名apk，默认名称为tap_unsign.apk<br>alias参数代表签名用的alias名称（创建keyStore时所填写），如timdong</p>
<pre><code>$ jarsigner -verbose -keystore debug.keystore -signedjar test2.apk tap_unsign1.apk timdong

Enter Passphrase for keystore: 

   adding: META-INF/MANIFEST.MF

   adding: META-INF/ANDROIDD.SF

   adding: META-INF/ANDROIDD.RSA

  signing: res/drawable/ic_launcher.png

  signing: res/layout/main.xml

  signing: AndroidManifest.xml

  signing: resources.arsc

  signing: classes.dex
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1_u3001_u67E5_u770B_keystore"><a href="#1_u3001_u67E5_u770B_keystore" class="headerlink" title="1、查看 keystore"></a>1、查看 keystore</h3]]>
    </summary>
    
      <category term="Keystore" scheme="http://janrone.allone.top/tags/Keystore/"/>
    
      <category term="Adnroid" scheme="http://janrone.allone.top/categories/Adnroid/"/>
    
  </entry>
  
</feed>
