<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Janrone‘s Site</title>
    <link>https://janrone.allone.top/</link>
    <description>Recent content on Janrone‘s Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 11 Mar 2022 21:47:26 +0800</lastBuildDate><atom:link href="https://janrone.allone.top/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>周报005|娱乐至死，无声无息</title>
      <link>https://janrone.allone.top/weekly/%E5%91%A8%E6%8A%A5005-%E5%A8%B1%E4%B9%90%E8%87%B3%E6%AD%BB%E6%97%A0%E5%A3%B0%E6%97%A0%E6%81%AF/</link>
      <pubDate>Fri, 11 Mar 2022 21:47:26 +0800</pubDate>
      
      <guid>https://janrone.allone.top/weekly/%E5%91%A8%E6%8A%A5005-%E5%A8%B1%E4%B9%90%E8%87%B3%E6%AD%BB%E6%97%A0%E5%A3%B0%E6%97%A0%E6%81%AF/</guid>
      <description>我的周报：记录一周阅读和学习主要内容，以及工作和生活中的感悟！
 一切公众话语日渐以娱乐的方式出现，并成为一种文化精神。 我们的政治、宗教、新闻、体育、教育和商业都心甘情愿地成为娱乐的附庸，毫无怨言，甚至无声无息，其结果是我们成了一个娱乐至死的物种。 ——尼尔·波兹曼
 有声有色     《银行家》：永远需要有人敢于抗争  影片《银行家》改编自真实故事，发生在美国 20 世纪 50 年代。出生在德克萨斯州的黑人伯纳德，从小立志要学白人赚钱，改变自己的命运。他从小小的擦鞋匠发展成美国数一数二的黑人富豪，买大楼，买银行。用白人的钱放贷给黑人进行投资。无数在当时看来不可思议，不可理喻的疯狂想法，在伯纳德身上一一实现。 伯纳德从最初的投资楼盘，到后来买下洛杉矶最核心商业地段的楼王，再到后来买下德州的两家银行，试图用自己的力量帮助整个德州黑人生存境况，这显然已经超越了财富层面，触及政治。很快，伯纳德被指控，银行被关闭。
伯纳德，最终选择说出真话。等待他的就是三年牢狱之灾和没收全部资产，回到一贫如洗。这不是一部爽剧，所以很可惜，真实境况就是如此。伯纳德从坐拥 177 幢楼，到最后只剩 1 幢栖身之地。接受从天上到地下的炼狱之行。但是，他们的牺牲，也换来了三年后美国颁布废除《种族隔离法》。黑人不再被隔离，种族平等又向前迈进一大步。
人类的所有前进，都是无数个体牺牲小我从而获得的。无一例外。 中国现在缺少脊梁！
 人间烟火：一座来了便不想离开的城市  毕竟，无论是纽约东京还是北京上海，都可以说，如果你爱他，就带他去那儿吧，因为那是天堂。如果你恨他，就带他去那儿吧，因为那里是地狱。
但对于成都，我想只能说，带上你所爱的与所恨的去那儿吧，因为那里就是人间。
一直想去成都，疫情耽误了3年了。读了这文章之后，感觉更想去了！
人间成都 读书破万卷     生活十讲｜蒋勋 ：幸福的做自己  《生活十讲》预告:找回生活的信仰
现在的社会越来越焦虑，整体的物化，使人们的价值观发生了巨大改变，如何重拾我们的信仰，幸福的做自己。
“有自信的人，对于自己所拥有的东西，是一种充满而富足的感觉，他可能看到别人有而自己没有的东西，会觉得羡慕、敬佩，进而欢喜赞叹，但他回过头来还是很安分地做自己。”
这句话印在《生活十讲》的自序之前，在这到处都是攀比的社会中，是一道清流。  《投资者的未来》 一本书粉碎了传统理念，为那些力图在长期成为赢家的投资者提供了一个选择股票的框架。  新增加到标准普尔 500 指数中的股票表现落后于该指数的原始股。
这样的结果引出一个重要的问题，如果 “老的” 总是比 “新的” 表现得更出色，那么当初 “新的” 为什么要被创造出来呢？
答案很简单。对于企业家、风险投资家以及投资银行家来说，新公司能够创造出巨大的利润。
但是对于购买这些股票的投资者来说，则又是另外一回事了。大众热切地想要捕捉到机会，结果却为这些驱动经济前进的公司付出了过高的价格。
数据与观察      大宗生，万物死   俄乌大战 真是开眼了 股市大跌，欧美和俄罗斯互相没收各自国家企业的财产。西方私有财产神圣不可侵犯的根本算是彻底打破。</description>
    </item>
    
    <item>
      <title>周报004|初心不改，逐梦而行</title>
      <link>https://janrone.allone.top/weekly/%E5%91%A8%E6%8A%A5004-%E5%88%9D%E5%BF%83%E4%B8%8D%E6%94%B9%E9%80%90%E6%A2%A6%E8%80%8C%E8%A1%8C/</link>
      <pubDate>Fri, 04 Mar 2022 21:47:26 +0800</pubDate>
      
      <guid>https://janrone.allone.top/weekly/%E5%91%A8%E6%8A%A5004-%E5%88%9D%E5%BF%83%E4%B8%8D%E6%94%B9%E9%80%90%E6%A2%A6%E8%80%8C%E8%A1%8C/</guid>
      <description>我的周报：记录一周阅读和学习主要内容，以及工作和生活中的感悟！
有声有色     纪录片《但是，还有书籍》 ，人类有书就不孤单。   但是，还有书籍，我直接看的是第二季，真的好看。我连续看了两集，突然我觉得我想做作家和画家。 哈哈哈 。
我在想，人类的终极追求应该就是那个样子吧，内心和精神的追求，而不是财富。
如果有天堂，那一定是图书馆的模样。 —— 博尔赫斯
俄乌大战     瑞士制裁俄罗斯 世界真的变了。  整个欧洲各国都站出来制裁俄罗斯。援助乌克兰。他们都是战争的帮凶。
泽连斯基，给乌克兰人民带来了战争！
读书破万卷     《投资者的未来》 一本书粉碎了传统理念，为那些力图在长期成为赢家的投资者提供了一个选择股票的框架。  一种流行的说法认为泡沫会在所有空头都被轧平时达到顶峰。同时，卖空者中间那些拥有足够资金和钢铁般神经的人最终会得到奖赏。而对于其他人来说，最好的建议是站在外面欣赏这场演出，不要到舞台上去凑热闹。
记住，不管泡沫是否存在，定价永远是重要的。那些为了追求增长率舍得付出任何价格的人最终将会被市场狠狠地惩罚。
购买首次公开发行股票的投资者在取得较低回报率的同时还要承担更大的风险。显然，和买彩票一样，这样的策略在长期中是不可取的。
数据与观察      1-2月房地产销售金额，只能用垮塌两个字来形容。   杨利娟 最牛服务员
  2018年，海底捞上市。
彼时，创始人张勇夫妇从2017年的50亿财富，到身价600亿，一跃成为中国前50名的富豪。
但身价暴涨的并不止张勇夫妇，17 岁就跟着张勇做服务员的杨利娟，在海底捞上市后，身价蹿升至 30 亿，被称为中国最牛服务员。
胡言乱语      “人人过关的手段在西方国家轰轰烈烈的上台了，又是开除又是没收财产，现在他们怎么对俄裔，将来他们就怎么对华裔。”————确实就会是这样子！ ​​​
  晚上吃饭的时候突然想到了这首歌，😓    感谢你阅读到这里！如果你觉得内容还不错，可以帮忙转发分享留言，让更多人看到！也欢迎找我沟通交流！</description>
    </item>
    
    <item>
      <title>周报003|心之所愿，无问东西</title>
      <link>https://janrone.allone.top/weekly/%E5%91%A8%E6%8A%A5003-%E5%BF%83%E4%B9%8B%E6%89%80%E6%84%BF%E6%97%A0%E9%97%AE%E4%B8%9C%E8%A5%BF/</link>
      <pubDate>Fri, 25 Feb 2022 21:47:26 +0800</pubDate>
      
      <guid>https://janrone.allone.top/weekly/%E5%91%A8%E6%8A%A5003-%E5%BF%83%E4%B9%8B%E6%89%80%E6%84%BF%E6%97%A0%E9%97%AE%E4%B8%9C%E8%A5%BF/</guid>
      <description>我的周报：记录一周阅读和学习主要内容，以及工作和生活中的感悟！
有声有色      等待戈多的大字报·桒悳SOUND·第二季·No.14
因为听了阿鹏的桒惪No.14等待戈多的大字报（（2012年的播客）），而太过喜欢，因此贴过来自勉。
最大的感受，从2012到2022我们的焦虑从来没有减少和改变过！
  我们出生在一个见证历史得得时代！
俄罗斯进军乌克兰    古往今来，平民永远是战争中最大的输家。 希望反战会成为所有人的共识。
读书破万卷     《投资者的未来》 一本书粉碎了传统理念，为那些力图在长期成为赢家的投资者提供了一个选择股票的框架。  总结的数据显示了从1957～2003年每个部门的收益率与其市场份额的变化的对比情况。
数据显示了在长期中成为赢家的三个板块，它们是卫生保健部门、日常消费品部门和能源部门。前两者占据了标准普尔500指数20家最佳“幸存”公司90%的名额。这两个部门中的许多杰出公司都致力于将高质量的产品推向市场，并且在世界范围拓展品牌认同度。
铁路业给投资者上了重要的一课：一个长期下滑的行业也可以向股东提供出色的收益率。在市场预期如此悲观的情况下，如果公司能够止住下滑并赢取利润，特别是如果管理层能够支付股利，那么投资这家公司股票的未来收益将十分可观。30年前，又有谁会想到萧条的铁路业能够带给投资者如此丰厚的回报，而蓬勃的航空业会做得如此之差呢？
数据与观察      俄国侵占我国领土，至1945年止，共有5883800平方公里，占全国面积三分之一。
  约160年前，沙皇俄国通过《瑷珲条约》、《北京条约》，前后从清政府手里划走了中国东北端的两块土地，大约100万平方公里。
  统治者保护自己财产不遗余力 保护自己人民却显得那么力不从心 //@吾日新:一份有关外地妇女被哄骗、劫持、拐卖到江苏省徐州市的调查报告中，赫然罗列着这样几组数字(这仅仅是一个最保守的数字)。 自1986年以来： 铜山县12000人 睢宁县8700人 邳县 9400人 丰县 8100人 沛县 5300人 新沂县4600人。
  QFII持股前50名   胡言乱语      全国政协委员建议收买妇女产生的婚姻关系无效。#闲言碎语# ​​​
  战争会结束，太阳会继续升起，睡觉。 ​​​</description>
    </item>
    
    <item>
      <title>周报002|不谋万世者,不足谋一时</title>
      <link>https://janrone.allone.top/weekly/%E5%91%A8%E6%8A%A5002-%E4%B8%8D%E8%B0%8B%E4%B8%87%E4%B8%96%E8%80%85%E4%B8%8D%E8%B6%B3%E8%B0%8B%E4%B8%80%E6%97%B6/</link>
      <pubDate>Fri, 18 Feb 2022 21:47:26 +0800</pubDate>
      
      <guid>https://janrone.allone.top/weekly/%E5%91%A8%E6%8A%A5002-%E4%B8%8D%E8%B0%8B%E4%B8%87%E4%B8%96%E8%80%85%E4%B8%8D%E8%B6%B3%E8%B0%8B%E4%B8%80%E6%97%B6/</guid>
      <description>我的周报：记录一周阅读和学习主要内容，以及工作和生活中的感悟！
 坚持确实不是一件容易的事情，才第二周，我竟然放弃了！
 周末大雪    &amp;lt;,,&amp;gt;
北京市教委 学生打疫苗    今天的事情发生在林日朗身上，明天就能发生在我们身上。//@幸运精灵公主:请依法行政，不要变相强制儿童打疫苗！！！#误杀2#
@北京市教委 #启示录# 生活、工作、学习倘使都能自动，则教育之收效定能事半功倍。所以我们特别注意自动力之培养，使它关注于全部的生活工作学习之中。自动是自觉的行动，而不是自发的行动。自觉的行动，需要适当的培养而后可以实现。——陶行知
观察与数据     法国是全世界核电在电力结构中占比最高的国家，电量占比约为70%，远高于其他国家。其核电装机容量达到6137万千瓦，仅次于美国。  读书破万卷     《投资者的未来》 一本书粉碎了传统理念，为那些力图在长期成为赢家的投资者提供了一个选择股票的框架。   投资的一条基本原则：不要购买“市盈率远远高于市场总体水平”的股票，尤其是大盘股，如果你的目的是要进行长期投资，就更应该遵循这条原则。 大部分表现最好的公司拥有：①略高于平均水平的市盈率；②与平均水平持平的股利率；③远高于平均水平的长期利润增长率。表现最好的股票中没有一只市盈率超过27。这些就是旗舰企业的特征。 对投资者而言，表现最好的公司来自拥有知名品牌的日常消费品行业和制药行业。正如沃伦·巴菲特所说：“那些被又宽又深的壕沟保护着的产品或服务才能带给投资者最好的收益。 （旗舰企业的共同特征）这些公司中的绝大多数都拥有高质量的品牌产品，并且成功地在世界各地开拓了市场。消费者对产品质量的信赖使公司可以把产品价格定到竞争者之上，这一点对于它们的成功至关重要。 如果我来到某个偏僻的地方，我也许会在商店里同时找到箭牌口香糖和Glotz口香糖。我知道箭牌很不错，同时我对Glotz一无所知。如果前者卖40美分而后者卖30美分，那么我会为了省下区区10美分而选择把自己从未听说过的东西塞进嘴里吗？这无数个“区区10美分”加总在一起，可不是一个小数目。  胡言乱语      “工作赶跑了三个魔鬼：无聊、堕落和贫穷。”——伏尔泰
  最好的教育 一定来之于家庭
  #丰县生育八孩女子事件调查组成立# 有些事儿，需要中央成立调查组才能查清。 ​
  莫言说：“不用等死后，活着就能看见地狱。”他说得对。
有人说：“我穿过17曾地狱，来到18层，听到有声音说‘欢迎来到人间’。”他说得更对。
  【冬奥时刻】为你骄傲，最好的范可新！   @徐梦桃 难道不值得吗 [二哈] //@吾日新:一个美籍混血而已 天天推   之前听说有被骗去菠菜场，现在竟然有血奴，有些地方简直是地狱！</description>
    </item>
    
    <item>
      <title>周报001|还有多少个十年</title>
      <link>https://janrone.allone.top/weekly/%E5%91%A8%E6%8A%A5001-%E8%BF%98%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%8D%81%E5%B9%B4/</link>
      <pubDate>Sat, 12 Feb 2022 21:34:26 +0800</pubDate>
      
      <guid>https://janrone.allone.top/weekly/%E5%91%A8%E6%8A%A5001-%E8%BF%98%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%8D%81%E5%B9%B4/</guid>
      <description>我的周报：记录一周阅读和学习主要内容，以及工作和生活中的感悟！
 千里之行，始于足下！
 公众号注册也有很久了，之前主要记录了投资相关的内容，日更真的做不到，主要是内容输出对我来说着实困难，也不想一些废话！哈哈。
周报的想法（也有受老胡的周刊的启发）已经有很久，一直没有写拖到现在。
还有多少个十年 沈宁 - 还有多少个十年(励志版2019)
写文章之前刚听到这歌，感觉不错，大家可以边听边看，周到吧，嘿嘿！
一个有意思工具 反相词典    https://wantwords.thunlp.org/。
https://wantwords.net/
普通的词典告诉你某个词语的定义，而反向词典恰好相反，可以告诉你哪些词语符合你输入描述的意思。下图为万词王在线反向词典的页面截图，其中演示了反向查词的一个示例，输入“山非常高”，系统将返回一系列模型认为表达“山非常高”意思的词语，例如“高峻”、“巍峨”等。
Free Solo 纪录片 徒手攀岩大神Alex    一个字牛皮，没有之一！因为是一个人徒手没有任何辅助工具。失误就是粉身碎骨，不成功便成仁！
耸立于美国约塞米蒂国家公园内的酋长岩（El Capitan）是攀爬爱好者心目中的圣地和“宇宙中心”。这块完整的花岗岩以陡峭和凶险著称，几乎90度的立面，光滑无比，高916米，有号称全球最硬核的攀爬路线。
2014年，美国专业攀登者Tommy Caldwell在花了2年时间研究考察后，完成了酋长岩东南面（southeast face）的线路Dawn Wall Free的首次自由攀登。全程一共32个绳距，最高难度5.14C，762米，耗时19天。汤米哥吃喝拉撒都在岩壁上，他和同伴一起，用绳子保护，把整个线路分成多个小段进行，逐一攻破。
Tommy的成绩已经非常惊人了。然而2017 年 6 月 3 日，一位惊天地泣鬼神的超人，美国人亚历克斯霍诺德 ( Alex Honnold )在没有任何保护、没有攀爬伴侣的情况下徒手攀爬约 4 小时，成为全宇宙首位Free Solo（徒手攀登）酋长岩的人。
Alex徒手攀登的线路名称是 Freerider Route，位于酋长岩西南面，高度1005.84米，最高难度5.13a。注意， Tommy用的是Free Climb模式，而Alex Honnold用的是Free Solo方式。这两个英文虽然相似，性质却天差地别。
“Free Solo”这个词由两部分组成，Free是指Free of Aid，即没有任何工具辅助，Solo的意思是指独自一人。Alex在Free Solo攀登酋长岩的时候没有任何伙伴，也没有任何辅助他攀爬的工具，比如绳子和其他“硬件”（piton, nuts, cams）。通常这些工具能帮助攀岩者更好地粘附在岩壁上。Alex全程只穿着攀岩鞋，背了一只粉袋，里面的粉用来涂抹双手增强摩擦力。
这些年来，Alex被问最多的一个问题是：难道你不怕死吗？你不害怕掉下来吗？毕竟过去40年，只有十几个人做过Free Solo攀爬，其中一半的人都死了。
我最好奇的点，是Alex如何克服恐惧，他又如何看待风险。因为哪怕是一阵风吹来，或者是脚底一打滑，有几只鸟飞过，或者他打了个喷嚏，稍有闪失，都会落入万丈深渊。他不怕死吗？为什么一定要去Free Solo？为什么故意将自己暴露在无限的危险之下？他究竟是什么样的怪物？ 对于人们的疑惑，Alex的回答是那么朴素：山在那，不去爬，我永远不会满足。
“谁都能活得舒服快活，但如果人人都追求舒适快活，世界就无法进步。你知道，吃得苦中苦，方为人上人。在我看来，生命之意义在于奋勇当先，至于个中原因，倒不见得多么重要，这就是你的人生道路，你要好好走下去。你直面恐惧，只因这是实现目标的必然要求。这就是他妈的勇士精神。”
电影 误杀2 值得一看    医院外的围观群众，为何知道林日朗劫持事件的缘由后都支持林日朗。</description>
    </item>
    
    <item>
      <title>Now</title>
      <link>https://janrone.allone.top/now/</link>
      <pubDate>Wed, 18 Aug 2021 21:34:26 +0800</pubDate>
      
      <guid>https://janrone.allone.top/now/</guid>
      <description>再见过去，已至当下！    生    享受与家人相处的美好时光！
没有什么问题是睡一觉解决不了的，如果没解决，那就再睡一觉！
活    在一家小公司做Android开发，农业相关的项目。</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://janrone.allone.top/about/</link>
      <pubDate>Sat, 14 Aug 2021 16:03:26 +0800</pubDate>
      
      <guid>https://janrone.allone.top/about/</guid>
      <description>一些对自己和看到我博客人说的话：    做自己。
投资自己。
不做空！
珍爱生命，远离杠杆！
价值投资。价值投资一个说的人多，做的人不多的事情！
温饱解决了，起码有点小追求小梦想啥的！ 保持好奇心！即使你因此吃过亏。
你可以停止好奇，但我认为那样的你已经死掉了。 要敢于想象，有想象力！
所有资产，如果都可以变成数字资产，那就太酷了。
不要浪费时间到无关事和人的身上，毕竟生命太短暂了。
有些执念根本没有意义！
要允许有遗憾！敢于说再见！
真知即是意义！</description>
    </item>
    
    <item>
      <title>博客重建，三年已过</title>
      <link>https://janrone.allone.top/posts/rebuild_blog_three_yeas_pass/</link>
      <pubDate>Sat, 14 Aug 2021 01:10:33 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/rebuild_blog_three_yeas_pass/</guid>
      <description>互联网    从最早的折腾octopress到hexo再到hugo，一眨眼已经有小十年了。 这十年国内互联网飞速发展再到现在如此内卷，几大互联网巨头更是依仗自己的优势压榨用户。 以至于国家都出手打压各大巨头，先是阿里被罚，然后又是腾讯，美团。
大厂不知道什么时候流行起来996风气。不少95，甚至00都失去了应该有的个性。加入了内卷的队伍。
移动互联网起步到热火朝天再到现在内卷，基本没有创新，只是在做些替代传统的工作。
最早看好的APP，有Keep ，雪球。
还有就是加密货币的出现简直就是造富运动，经历一波大牛市。一堆人一夜暴富，当然炒币的人也有丢了小命的。
A股2015也经历一波大牛市。
短视频的诞生，抖音，快手已经毒入人心，上至80岁的耄耋老者，下至蹒跚学步的孩童都会抱着手机上划。
美团从千团大战活了下来，搞起了送外卖的行当。
我的博客进化史    1，怎么在github 搭建 Octopress
2，利用Daocloud持续部署Hexo
3，自动部署Hugo到github page https://tianhui.xin/blog/2019/11/17/hugousegithubactionstopages/</description>
    </item>
    
    <item>
      <title>三种碰撞检测</title>
      <link>https://janrone.allone.top/posts/2018-04-28-%E4%B8%89%E7%A7%8D%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Wed, 04 Apr 2018 16:36:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2018-04-28-%E4%B8%89%E7%A7%8D%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/</guid>
      <description>碰撞检测    碰撞检测技术 可通过多种方式检测 sprite 之间的碰撞。可采用的三种流行技术（按先进程度和复杂度递增顺序排列）是：
边界区域（在 3D 游戏中称为包围体） 光线投射 分离轴定理 (Separating Axis Theorem) 使用边界区域的碰撞检测，检测圆圈或多边形的交点。在 图 2 中的示例中，小圆圈是表示一个 sprite（一个小球）的边界区域，大圆圈是一个桶的 sprite 的边界区域，桶比球大。当两个圆形边界区域相交时，球就会掉落到桶中。
图 2. 边界区域：圆圈之间的碰撞 该图演示了圆圈之间的碰撞检测的原理 检测两个圆圈的碰撞是所有碰撞检测技术中最简单的。如果两个圆圈中心之间距离小于圆圈的半径之和，就会相交，sprite 就会爆炸。
边界区域碰撞检测很简单，但当边界区域太小或移动得太快时，检测可能失败。在这两种情况下，sprite 可在单个动画帧中彼此穿过，进而避免检测。
对于小型、快速移动的 sprite，更加可靠的一种技术是光线投射，如 图 3 所示。光线投射检测两个 sprite 的速度向量的焦点。在 图 3 中的 5 个帧中，球的速度向量是以蓝色绘制的对角线，桶的速度向量是红色的水平线（桶水平移动）。在这些向量的交点位于桶顶部的开口内，并且球在开口下方时，球就会落入桶中，如 图 3 中最右边的屏幕截图中所示。
图 3. 光线投射 该图演示了光线投射碰撞检测的原理 先验或后验碰撞检测 可在碰撞发生之前（先验）或之后（后验）它们。如果在碰撞发生之前进行检测，必须预测 sprite 未来将位于何处。如果在碰撞发生之后检测，通常需要将已碰撞的 sprite 分开。这两种方法孰优孰劣并不明显。
光线投射非常适合以下环境中的简单形状（比如 图 2 中球落在桶中），其中给出了两个形状的速度向量的焦点，很容易确定它们是否已经发生碰撞。
对于更复杂的场景，比如任意大小和形状的多边形之间的碰撞，分离轴定理是最可靠的（和最复杂的）碰撞检测技术之一。分离轴定理是将光线从两个不同的角度照射到两个多边形上的数学描述，如 图 4 中所示。如果多边形背后的墙上的影子露出空隙，那么多边形没有发生碰撞。
图 4. 分离轴定理 该图演示了使用分离轴定理的碰撞检测的原理 本文不会进一步介绍光线投射或分离轴定理。您可以在 Core HTML5 Canvas（Prentice Hall，2012 年）中查阅每种方法的深入讨论。（请参阅 参考资料，获取相关链接。）</description>
    </item>
    
    <item>
      <title>如何在Excel中使用宏 (版本2013)</title>
      <link>https://janrone.allone.top/posts/2018-04-04-%E5%A6%82%E4%BD%95%E5%9C%A8excel%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%8F/</link>
      <pubDate>Wed, 04 Apr 2018 16:36:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2018-04-04-%E5%A6%82%E4%BD%95%E5%9C%A8excel%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%8F/</guid>
      <description>需求获取网页数据到Excel，用来统计。    1，创建宏：    新建Excel文档，点击视图，点击宏，创建 ，之后是编写宏。保存的时候，遇到到如下问题： 单击否，然后保存文件为 .xlsm 格式 。</description>
    </item>
    
    <item>
      <title>如何删除git历史记录</title>
      <link>https://janrone.allone.top/posts/2018-03-16-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4git%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Fri, 16 Mar 2018 10:36:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2018-03-16-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4git%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</guid>
      <description>清除所有历史    Step 1: remove all history
rm -rf .git  Step 2: reconstruct the Git repo with only the current content
git init git add . git commit -m &amp;quot;Initial commit&amp;quot;  Step 3: push to GitHub.
git remote add origin &amp;lt;github-uri&amp;gt; git push -u --force origin master  清空上某个文件的历史    首先cd 进入项目文件夹下，然后执行以下代码：
git filter-branch --force --index-filter &#39;git rm --cached --ignore-unmatch 文件名&#39; --prune-empty --tag-name-filter cat -- --all git push origin master --force rm -rf .</description>
    </item>
    
    <item>
      <title>JSON 解析时自动判断是Object还是Array</title>
      <link>https://janrone.allone.top/posts/2017-12-28-json-%E8%A7%A3%E6%9E%90%E6%97%B6%E8%87%AA%E5%8A%A8%E5%88%A4%E6%96%AD%E6%98%AFobject%E8%BF%98%E6%98%AFarray/</link>
      <pubDate>Fri, 17 Nov 2017 14:36:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2017-12-28-json-%E8%A7%A3%E6%9E%90%E6%97%B6%E8%87%AA%E5%8A%A8%E5%88%A4%E6%96%AD%E6%98%AFobject%E8%BF%98%E6%98%AFarray/</guid>
      <description>后端API数据返回有时候是Object有时候有是Array！    解决方案：通过JSONTokener解析，JSONTokener在解析过程中可以自动转换为对应的类型
代码示例如下：
 String json =&amp;quot;{\&amp;quot;scm\&amp;quot;:{\&amp;quot;key1\&amp;quot;:\&amp;quot;vlaue1\&amp;quot;,\&amp;quot;key2\&amp;quot;:\&amp;quot;vlaue2\&amp;quot;}}&amp;quot;; String json =&amp;quot;{\&amp;quot;scm\&amp;quot;:[{\&amp;quot;key1\&amp;quot;:\&amp;quot;vlaue1\&amp;quot;,\&amp;quot;key2\&amp;quot;:\&amp;quot;vlaue2\&amp;quot;},{\&amp;quot;key11\&amp;quot;:\&amp;quot;vlaue11\&amp;quot;,\&amp;quot;key22\&amp;quot;:\&amp;quot;vlaue22\&amp;quot;}]}&amp;quot;; JSONObject jsonObject =JSONObject.fromObject(json); Object listArray = new JSONTokener(jsonObject.getString(&amp;quot;scm&amp;quot;)).nextValue(); if (listArray instanceof JSONArray){ JSONArray jsonArray = (JSONArray)listArray; for (int k = 0; k &amp;lt; jsonArray.size(); k++) { JSONObject parameterObject = jsonArray.getJSONObject(k); } }else if (listArray instanceof JSONObject) { JSONObject jsonObject3 = (JSONObject)listArray; }  最后搞定 。
参考：http://blog.csdn.net/xlyrh/article/details/75091353</description>
    </item>
    
    <item>
      <title>Scrapy安装和问题处理</title>
      <link>https://janrone.allone.top/posts/2017-11-17-scrapy%E5%AE%89%E8%A3%85%E5%92%8C%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 17 Nov 2017 14:36:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2017-11-17-scrapy%E5%AE%89%E8%A3%85%E5%92%8C%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</guid>
      <description>安装 scrapy    windows 安装
pip install Scrapy  结果报错：
building &#39;twisted.test.raiser&#39; extension error: [WinError 2] 系统找不到指定的文件。  +++ Command &amp;ldquo;d:\python\python.exe -u -c &amp;ldquo;import setuptools, tokenize;file=&amp;lsquo;C:\Users\Tuteng\AppData\Local\Temp \pip-build-l7ra5rw5\Twisted\setup.py&amp;rsquo;;f=getattr(tokeniz e, &amp;lsquo;open&amp;rsquo;, open)(file);code=f.read().replace(&#39;\r\n&#39;, &amp;lsquo;\n&amp;rsquo;);f.close();exec(compile(code, file, &amp;lsquo;exec&amp;rsquo;))&amp;rdquo; install &amp;ndash;record C:\Users\Tuteng\AppData\Local\Temp\pip-yon9xl5j-record\ins tall-record.txt &amp;ndash;single-version-externally-managed &amp;ndash;compile&amp;rdquo; failed with error code 1 in C:\Users\Tuteng\AppData\Local\Temp\pip-build-l7ra5rw5\Twis ted\
因为scrapy框架是基于twisted 的， 所以又要去上面那个网站： http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml
搜Twisted    Twisted, an event-driven networking engine. Twisted, an event-driven networking engine. ● Twisted‑17.9.0‑cp27‑cp27m‑win32.whl ● Twisted‑17.</description>
    </item>
    
    <item>
      <title>使用Gradle构建多个不同applicationId包</title>
      <link>https://janrone.allone.top/posts/2017-05-13-%E4%BD%BF%E7%94%A8gradle%E6%9E%84%E5%BB%BA%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8Capplicationid%E5%8C%85/</link>
      <pubDate>Sat, 13 May 2017 14:36:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2017-05-13-%E4%BD%BF%E7%94%A8gradle%E6%9E%84%E5%BB%BA%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8Capplicationid%E5%8C%85/</guid>
      <description>假设下面是我们的目前的代码，想要哪个地址就改下API_URL重新打个包就ok了
public static final String API_URL = &amp;ldquo;http://www.google.com&amp;rdquo;;//美国us// public static final String API_URL = &amp;ldquo;http://www.nanfei.com&amp;rdquo;;//南非za public static final String API_URL = &amp;ldquo;http://www.baidu.com&amp;rdquo;;//本地
localRetrofit retrofit = new Retrofit.Builder().baseUrl(API_URL).client(client).addConverterFactory(GsonConverterFactory.create()) .build();
可是有一天，测试同事跑来说，每次测试不同版本只能安装一个app(applicationId是唯一的,会进行覆盖),他想在同一台手机上安装多个app，app之间的区别只是它们的后台服务接口地址API_URL不同，当然最好app的桌面名字能区分出来是哪个服务接口地址,这样测试就方便了
如何实现呢，同时打多个包肯定会想到用productFlavors，同时API_URL和app_name需要动态改变。
1.移除strings的app_name    由于app_name是动态的所以肯定不能写死了,把它删掉
2.设置build.gradle的productFlavors    productFlavors { local { applicationId &amp;ldquo;com.lwp.app&amp;rdquo; buildConfigField &amp;lsquo;String&amp;rsquo;, &amp;lsquo;API_URL&amp;rsquo;, &amp;lsquo;&amp;ldquo;http://www.baidu.com&amp;rdquo;&amp;rsquo; resValue &amp;ldquo;string&amp;rdquo;, &amp;ldquo;app_name&amp;rdquo;, &amp;ldquo;app&amp;rdquo;
} us { applicationId &amp;ldquo;com.lwp.app.us&amp;rdquo; buildConfigField &amp;lsquo;String&amp;rsquo;, &amp;lsquo;API_URL&amp;rsquo;, &amp;lsquo;&amp;ldquo;http://www.google.com&amp;rdquo;&amp;rsquo; resValue &amp;ldquo;string&amp;rdquo;, &amp;ldquo;app_name&amp;rdquo;, &amp;ldquo;app_us&amp;rdquo;
} za { applicationId &amp;ldquo;com.</description>
    </item>
    
    <item>
      <title>Shell命令</title>
      <link>https://janrone.allone.top/posts/2016-05-29-shell%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sun, 29 May 2016 20:36:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2016-05-29-shell%E5%91%BD%E4%BB%A4/</guid>
      <description>###（一）文件创建命令
1.touch命令    例如：touch abc命令在本地目录中创建了一个名为abc的空文件  2.cp命令    cp命令允许我们把一个文件的内容复制到同名或不同名的文件中，复制得到的文件可以在任何目录。 使用cp命令的一个风险	是它会在不提示用户的情况下很容易覆盖掉不同目录中的文件 -r选项支持递归复制。例如：cp -ar /usr/share/doc/. /doc/ 将复制源目录中所有子目录以及相关文件  3.mv命令    mv命令实质上市给文件贴上不同的标签，例如：mv file1 file2 命令就是把file1的名字改为file2 mv命令也可以用于目录  4.ln命令    链接文件允许用户编辑不同目录中的同一个文件 硬链接包含了文件的一个副本。只要硬链接文件是在同一个分区中，则它们的索引号相同 。 ln /etc/samba/smb.conf smb.conf 软连接起着重定向的作用。当我们打开一个用软链接创建的文件时，则链接把我们重定向到原来的文件。 ln -s /etc/	samba/smb.conf smb.conf  5.rm命令    -r开关选项可以按递归方式进行 -f开关选项可以覆盖掉任何安全措施 rm -rf /root/a/b  6.目录创建和删除    mkdir和rmdir命令用于创建和删除目录 -p no error if existing, make parent directories as needed 例如 mkdir -p /test1/test2/test3 rmdir -p /test1/test2/test3  7.</description>
    </item>
    
    <item>
      <title>Node与Express开发笔记一</title>
      <link>https://janrone.allone.top/posts/2016-05-26-node%E4%B8%8Eexpress%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%80/</link>
      <pubDate>Thu, 26 May 2016 18:38:13 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2016-05-26-node%E4%B8%8Eexpress%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B8%80/</guid>
      <description>前言    JavaScript、 Node 和 Express 的组合是 Web 团队的理想选择， 这个强大的、 可快速部署的技术栈得到了开发社区和大公司的广泛认可。
Node 和 Express 就像发射 JavaScript 希望之银弹的机关枪。
初识Express    老实说， JavaScript 确实降低了业余选手进入的门槛， 也有很多充斥着各种问题的 JavaScript 代码， 这损坏了 JavaScript 的名声。 用句通俗的话说， 即“ 不是游戏太差， 而是玩家太烂”。
Express 网站上是这样介绍 Express 的：“ 精简的、 灵活的 Node.js Web 程序框架， 为构建单页、 多页及混合的 Web 程序提供了一系列健壮的功能特性。”
单页Web程序    单页 Web 程序是比较新颖的想法。 不像之前的网站， 用户每次访问不同的页面都要发起网络请求， 单页 Web 程序把整个网站（ 或很大一部分） 都下载到客户端浏览器上。经过初始下载后， 用户访问不同页面的速度更快了， 因为几乎不需要或者只要很少的服务端通信。
单页程序的开发可以使用 Angular 或 Ember 等流行框架， Express 跟它们都配合得很好。</description>
    </item>
    
    <item>
      <title>利用Daocloud持续部署Hexo</title>
      <link>https://janrone.allone.top/posts/2016-05-10-%E5%88%A9%E7%94%A8daocloud%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2hexo/</link>
      <pubDate>Tue, 10 May 2016 13:25:42 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2016-05-10-%E5%88%A9%E7%94%A8daocloud%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2hexo/</guid>
      <description>Hexo安装    npm install -g hexo //安装完成后，进入到Hexo文件夹目录， 即会自动在目标文件夹建立网站所需要的所有文件。 hexo init //初始化 npm install //安装依赖包 hexo g //生成静态的网页 hexo s //开启本地服务，可以在本地预览 Hexo d //上传生产的文件到配置的服务仓库（见_config.yml）  官方文档：https://hexo.io/docs/
同时部署到Coding和Github平台    Coding Pages    Coding Pages 是一个免费的静态网页托管和演示服务。
在Coding创建一个和你用户相同项目用来部署你的Hexo 。
同时在代码选项开启的你的 pages服务。分支填写master(这里的分支要和部署时的对应)。
用户 Pages 可以通过{user_name}.coding.me 形式的 URL 直接访问。
官方文档 https://coding.net/help/doc/pages/index.html
Github pages    同样Gtihub也提供了一个 Pages免费服务。 同样你在Github创建一个名为username.github.io的仓库 。用来部署你的Hexo代码。
官方文档 https://pages.github.com/
_config.yml配置    同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下
deploy: type: git repo: github: &amp;lt;repository url&amp;gt;,[branch] coding: &amp;lt;repository url&amp;gt;,[branch]  Daocloud 自动构建    项目主页：http://daocloud.</description>
    </item>
    
    <item>
      <title>Mac上Ruby和RubyGems安装使用说明</title>
      <link>https://janrone.allone.top/posts/2016-03-26-mac%E4%B8%8Aruby%E5%92%8Crubygems%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Sat, 26 Mar 2016 15:52:33 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2016-03-26-mac%E4%B8%8Aruby%E5%92%8Crubygems%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</guid>
      <description>安装 RVM    RVM:Ruby Version Manager,Ruby版本管理器，包括Ruby的版本管理和Gem库管理(gemset)
　$ curl -L https://get.rvm.io | bash -s stable 然后，载入 RVM 环境    　$ source ~/.rvm/scripts/rvm
查看当前ruby版本    $ ruby -v ruby 1.8.7 #列出已知的ruby版本 $ rvm list known #安装ruby 1.9.3 $ rvm install 1.9.3 步骤3 － 设置 Ruby 版本  RVM 装好以后，需要执行下面的命令将指定版本的 Ruby 设置为系统默认版本
　$ rvm 2.0.0 &amp;ndash;default 有可能是因为Ruby的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，网上的一种解决方案是将远替换成淘宝的，替换方式如下：
$ gem source -r https://rubygems.org/ $ gem source -a https://ruby.</description>
    </item>
    
    <item>
      <title>Mac下安装及配置 ProxyChains-NG 实现终端下代理</title>
      <link>https://janrone.allone.top/posts/2016-03-26-mac%E4%B8%8B%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-proxychains-ng-%E5%AE%9E%E7%8E%B0%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%BB%A3%E7%90%86/</link>
      <pubDate>Sat, 26 Mar 2016 13:30:42 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2016-03-26-mac%E4%B8%8B%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-proxychains-ng-%E5%AE%9E%E7%8E%B0%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%BB%A3%E7%90%86/</guid>
      <description>ProxyChains-NG    项目主页：https://github.com/rofl0r/proxychains-ng
官方说明：
proxychains ng (new generation) - a preloader which hooks calls to sockets in dynamically linked programs and redirects it through one or more socks/http proxies. continuation of the unmaintained proxychains project.
安装    使用 Homebrew 安装
brew install proxychains-ng
配置    编辑配置文件
sudo vim /usr/local/Cellar/proxychains-ng/4.10/etc/proxychains.conf  在 [ProxyList] 下面（也就是末尾）加入代理类型，代理地址和端口 注释掉原来的代理并添加
socks5 127.0.0.1 1080  ps: 默认的socks4 127.0.0.1 9095是tor代理，而socks5 127.0.0.1 1080是shadowsocks的代理。</description>
    </item>
    
    <item>
      <title>读写给大家看的设计书</title>
      <link>https://janrone.allone.top/posts/2016-01-13-%E8%AF%BB%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6/</link>
      <pubDate>Wed, 13 Jan 2016 15:20:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2016-01-13-%E8%AF%BB%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6/</guid>
      <description>{% cq %} 有些人需要设计页面，但完全没有设计背景，或者在设计方面没有经过正规培训，本书正是为这些人所写的。
From: 威谦斯 (Robin Williams). “写给大家看的设计书(第3版).” {% endcq %}
第一部分      4大设计原则
“对比（Contrast）”“重复（Repetition）”“对齐（Alignment）”“亲密性（Proximity）”
  “亲密性原则是指：将相关的项组织在一起，移动这些项，使它们的物理位置相互靠近，这样一来，相关的项将被看作凝聚为一体的一个组，而不再是一堆彼此无关的片段。”
“对齐原则是指：任何元素都不能在页面上随意安放。每一项都应当与页面上的某个内容存在某种视觉联系。”
  </description>
    </item>
    
    <item>
      <title>时间与艺术——怀表</title>
      <link>https://janrone.allone.top/posts/2016-01-07-%E6%97%B6%E9%97%B4%E4%B8%8E%E8%89%BA%E6%9C%AF-%E6%80%80%E8%A1%A8/</link>
      <pubDate>Thu, 07 Jan 2016 11:29:19 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2016-01-07-%E6%97%B6%E9%97%B4%E4%B8%8E%E8%89%BA%E6%9C%AF-%E6%80%80%E8%A1%A8/</guid>
      <description>1. 科普 Gold Filled , Gold Plated 与 14K金    Gold Filled 指的是将10Kt以上品位的金层用机械以高温高压处理的方式压延附着在金属基材（铜材等）上，也就是通常说的贴金。
美国联邦规定中，&amp;ldquo;Gold Filled&amp;quot;是指那些金层的重量在包括金属基材在内的总重量中占到1/20以上的制品。 粗略的计算大约应该是25微米左右的厚度 金制品一般表面刻有&amp;quot;GF&amp;rdquo;，&amp;ldquo;Gold Filled&amp;rdquo;
而在英国，两面贴金或全面贴金被称为&amp;quot;Filled&amp;quot;，单面或部分贴金是&amp;quot;Rolled&amp;quot;，刻印为&amp;quot;GR&amp;quot;，&amp;ldquo;Gold Rolled&amp;rdquo;。
Gold Plated 指的是采用电解法等方法使金层以微米单位附着在金属基材上，也就是通常说的镀金，但是准确地说，象这种薄薄的镀层应该称为&amp;quot;Flash&amp;quot;。
美国联邦规定中，10Kt以上的金镀层在0.5微米（约20/1000000厘米）以上的制品可标示为&amp;quot;GP&amp;quot;或&amp;quot;Gold Plated&amp;quot;。
还有，&amp;ldquo;GEP&amp;rdquo;，&amp;ldquo;Gold ElectroPlated&amp;rdquo; 指的是用电加工方法，金镀层约0.175微米的制品。 &amp;ldquo;Heavy Gold ElectroPlated&amp;rdquo; 指的是金镀层为2.5微米的制品。
14K金
K是确定金饰品中黄金含量的单位，英语为Karat，简称为“K”。14K黄金表示首饰中黄金含量为58.5%。
K金制规定K金分为24种，24k金为纯黄金，理论值为100%；相应地，1K=1/24，14K黄金的黄金含量计算公式如下：  14k=100%/24*14=58.333%（585‰）。为方便标识，国际上一般把14K金的黄金含量约定为58.5%。 14k黄金的出现，跟黄金本身的特点有关，是人们为了满足首饰的耐用性和多样性的需求，在实践中探索出来的：“黄金有一个特点是自身比较柔软，所以难以镶嵌制成比较精美的首饰款式，尤其是镶嵌珍珠、宝石和翡翠等珍贵宝石时，容易丢失。古人发现在纯金中加入少量的银、铜、锌等金属就可以增加黄金的硬度与韧性，进而制作出各式各样的金饰。”
2. 表外观    主要分没表盖（open-face）和有表盖（hunter），有表盖里面还分双表盖（double-hunter），半开（half-hunter），还有可不可以透视（skeleton）等等
3. 品牌    Hamilton（汉密尔顿）、Elgin（爱尔近）、Waltham（华生）、Hampton（汉普顿）、Illinois（伊利诺斯）、Westclox（西部钟表公司）等众多至今为人熟悉或似曾熟悉的品牌纷纷登上历史舞台，至此美国已成为制表业的世界第一大国。
4. 查询网址    英国银质怀表查询 http://www.silvermakersmarks.co.uk/index.htm
针对美国怀表生产日期查询的网址包括了华生、波尔、汉米尔顿、汉普顿、爱尔近、伊利诺斯、Southbend和Rockford等。
https://pocketwatchdatabase.com/</description>
    </item>
    
    <item>
      <title>Java IO中几个主要类介绍和使用</title>
      <link>https://janrone.allone.top/posts/2016-01-05-java-io-%E5%87%A0%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 05 Jan 2016 10:55:41 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2016-01-05-java-io-%E5%87%A0%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;h4 id=&#34;1-io流可以有三种分类方法&#34;&gt;
  1. I/O流可以有三种分类方法.
  &lt;a class=&#34;heading-link&#34; href=&#34;#1-io%e6%b5%81%e5%8f%af%e4%bb%a5%e6%9c%89%e4%b8%89%e7%a7%8d%e5%88%86%e7%b1%bb%e6%96%b9%e6%b3%95&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;第一, 输入流,输出流 .
第二, 字节流,字符流 . 
第三, 节点流(真正直接处理数据的) ,处理流(装饰加工节点流的) .
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-字节流&#34;&gt;
  2. 字节流
  &lt;a class=&#34;heading-link&#34; href=&#34;#2-%e5%ad%97%e8%8a%82%e6%b5%81&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;抽象类 &amp;lt;– 面向字节的文件流 .  
InputStream &amp;lt;– FileInputStream  
OutputStream &amp;lt;– FileOutputStream  

常用方法 
InputStream  int read(byte [] c,int off, int len)  
OutputStream voidwrite(byte [] c,int off, int len) .
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-字符流&#34;&gt;
  3. 字符流
  &lt;a class=&#34;heading-link&#34; href=&#34;#3-%e5%ad%97%e7%ac%a6%e6%b5%81&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;抽象类 &amp;lt;– 面向字符文件流 .
Reader &amp;lt;– FileReader 
Writer &amp;lt;— FileWriter 

常用方法 
FileReader int read(char [] c,int off, int len)   
FileWriter voidwrite(char [] c,int off, int len) .
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-节点流和处理流&#34;&gt;
  4. 节点流和处理流
  &lt;a class=&#34;heading-link&#34; href=&#34;#4-%e8%8a%82%e7%82%b9%e6%b5%81%e5%92%8c%e5%a4%84%e7%90%86%e6%b5%81&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;类
BufferdReader 可以称作字符、输入、处理流 .

方法
String readLine()

BufferdReader构造函数接受的是 Reader 类型的参数
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Android Studio 开发遇到错误和解决方法集合</title>
      <link>https://janrone.allone.top/posts/2015-12-29-android-studio-%E5%BC%80%E5%8F%91android%E9%81%87%E5%88%B0%E9%94%99%E8%AF%AF%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88/</link>
      <pubDate>Tue, 29 Dec 2015 19:28:59 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2015-12-29-android-studio-%E5%BC%80%E5%8F%91android%E9%81%87%E5%88%B0%E9%94%99%E8%AF%AF%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88/</guid>
      <description>1 .Duplicate files copied in APK META-INF/LICENSE.txt    android { packagingOptions { exclude &#39;META-INF/LICENSE.txt&#39; } } My logcat: log Execution failed for task &#39;:Prog:packageDebug&#39;. Duplicate files copied in APK META-INF/LICENSE.txt File 1: /home/scijoker/AndroidStudioProjects/ProgProject/Prog/libs/httpclient-4.1.1.jar File 2: /home/scijoker/AndroidStudioProjects/ProgProject/Prog/libs/httpclient-4.1.1.jar  解决方法    android { packagingOptions { exclude &#39;META-INF/DEPENDENCIES.txt&#39; exclude &#39;META-INF/LICENSE.txt&#39; exclude &#39;META-INF/NOTICE.txt&#39; exclude &#39;META-INF/NOTICE&#39; exclude &#39;META-INF/LICENSE&#39; exclude &#39;META-INF/DEPENDENCIES&#39; exclude &#39;META-INF/notice.txt&#39; exclude &#39;META-INF/license.txt&#39; exclude &#39;META-INF/dependencies.txt&#39; exclude &#39;META-INF/LGPL2.1&#39; } }  2 .</description>
    </item>
    
    <item>
      <title>使用Gradle命令打包Android应用</title>
      <link>https://janrone.allone.top/posts/2015-12-23-%E4%BD%BF%E7%94%A8gradle%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85android%E5%BA%94%E7%94%A8/</link>
      <pubDate>Wed, 23 Dec 2015 11:52:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2015-12-23-%E4%BD%BF%E7%94%A8gradle%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85android%E5%BA%94%E7%94%A8/</guid>
      <description>gradlew －－ gradle wrapper    ./gradlew -v 版本号 ./gradlew clean app目录下的build文件夹 ./gradlew build 检查依赖并编译打包,同时把debug、release环境的包都打出来。 ./gradlew installRelease Release模式打包并安装 ./gradlew uninstallRelease 卸载Release模式包 配合assemble ./gradlew assembleDebug 编译并打Debug包 ./gradlew assembleRelease 编译并打Release的包  其实 assemble 是和 Build Variants 一起结合使用的，而 Build Variants = Build Type + Product Flavor 除此之外 assemble 还能和 Product Flavor 结合创建新的任务，    ./gradlew assembleWandoujiaRelease 生成wandoujia渠道的release版本 ./gradlew assembleWandoujia 生成wandoujia渠道的Release和Debug版本 ./gradlew assembleRelease 生成全部渠道Release版本。即生成Product Flavor下的所有渠道的Release版本都打出来。  总结一下，assemble 命令创建task有如下用法：    **assemble**： 允许直接构建一个Variant版本，例如assembleFlavor1Debug。 **assemble**： 允许构建指定Build Type的所有APK，例如assembleDebug将会构建Flavor1Debug和Flavor2Debug两个Variant版本。 **assemble**： 允许构建指定flavor的所有APK，例如assembleFlavor1将会构建Flavor1Debug和Flavor1Release两个Variant版本。  最佳实践    signingConfigs { release { try { storeFile file(&amp;quot;xxxx&amp;quot;) storePassword KEYSTORE_PASSWORD keyAlias &amp;quot;xxxxx&amp;quot; keyPassword KEY_PASSWORD } catch (ex) { throw new InvalidUserDataException(&amp;quot;You should define KEYSTORE_PASSWORD and KEY_PASSWORD in gradle.</description>
    </item>
    
    <item>
      <title>在Android上搭建Python环境</title>
      <link>https://janrone.allone.top/posts/2013-04-09-%E5%9C%A8android%E4%B8%8A%E6%90%AD%E5%BB%BApython%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Tue, 09 Apr 2013 14:00:11 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2013-04-09-%E5%9C%A8android%E4%B8%8A%E6%90%AD%E5%BB%BApython%E7%8E%AF%E5%A2%83/</guid>
      <description>&lt;h3 id=&#34;1下载和安装-scripting-layer-for-android-sl4a&#34;&gt;
  1.下载和安装 Scripting Layer for Android (SL4A)
  &lt;a class=&#34;heading-link&#34; href=&#34;#1%e4%b8%8b%e8%bd%bd%e5%92%8c%e5%ae%89%e8%a3%85-scripting-layer-for-android-sl4a&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;Scripting Layer for Android (SL4A) 是一个开源项目，目标是为android系统提供脚本语言的支持，使用户可以直接在android平台上进行脚本语言的编辑、解释和执行。这些脚本语言已 经可是使用很多封装好的android API来开发功能丰富的android应用程序，并且使开发变得更加的简单和高效!
这个平台支持多种脚本语言，比如 Python, Perl, JRuby, Lua, BeanShell, JavaScript, Tcl, shell 等，你可以选择你熟悉的语言进行开发，本系列教程使用Python为编程脚本语言。
SL4A项目的地址: &lt;a href=&#34;http://code.google.com/p/android-scripting/&#34;&gt;http://code.google.com/p/android-scripting/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;2下载和安装-python-for-android&#34;&gt;
  2.下载和安装 Python for android
  &lt;a class=&#34;heading-link&#34; href=&#34;#2%e4%b8%8b%e8%bd%bd%e5%92%8c%e5%ae%89%e8%a3%85-python-for-android&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;在项目主页面的右上方，有该应用支持的所有脚本语言的下载列表，如下图所示;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://janrone.allone.top/images/post/2013-04-09-01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>怎么在github 搭建 Octopress </title>
      <link>https://janrone.allone.top/posts/2013-01-12-%E6%80%8E%E4%B9%88%E6%90%AD%E5%BB%BAoctopress%E5%9C%A8github/</link>
      <pubDate>Sat, 12 Jan 2013 20:34:13 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2013-01-12-%E6%80%8E%E4%B9%88%E6%90%AD%E5%BB%BAoctopress%E5%9C%A8github/</guid>
      <description>git 和 github 配置    1.先注册一个github账号， 创建github pages 。    创建一个新的Repository。这里须要重视的是，若是想要博客的首页是http://yourname.github.com，则Repository的project name就必须是yourname.github.com。
安装Git并进行设置，mac下git默认已经装好 。
2.接下来设置 SH Keys .    履行ssh-keygen -t rsa -C &amp;ldquo;your_email＠youremail.com&amp;rdquo;，回车。
然后输入两遍暗码。
到c:\Users\用户名.ssh\目次找到id_rsa.pub，并用文本软件打开复制全部。目录是隐藏的。
3.将SSH Key添加到GitHub    到github网站选择“Account Settings”&amp;raquo;“SSH Public Keys”&amp;raquo;“Add another public key”，将刚才复制的内容粘贴到key文本框内。
4. 测试    为确保设置成功，现在可以测试设置成果啦。记住，&amp;ldquo;git@github.com&amp;quot;是默认的，无需修改。
 $ ssh -T git@github.com （也可以用 SSH -v git@github.com ）  5.设置个人信息    现在，你已经成功安装Git，并设置好SSH Keys，是设置个人信息的时候啦：
设置用户名和电子邮件 $ git config &amp;ndash;global user.</description>
    </item>
    
    <item>
      <title>Android 用openFileOutput 和 openFileInput操作文件</title>
      <link>https://janrone.allone.top/posts/android-%E7%94%A8openfileoutput-%E5%92%8C-openfileinput%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6/</link>
      <pubDate>Sun, 11 Nov 2012 15:44:13 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/android-%E7%94%A8openfileoutput-%E5%92%8C-openfileinput%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6/</guid>
      <description>&lt;h5 id=&#34;照旧废话不说-贴代码&#34;&gt;
  照旧废话不说 贴代码
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e7%85%a7%e6%97%a7%e5%ba%9f%e8%af%9d%e4%b8%8d%e8%af%b4-%e8%b4%b4%e4%bb%a3%e7%a0%81&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h5&gt;
&lt;h5 id=&#34;文件操作类&#34;&gt;
  文件操作类
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c%e7%b1%bb&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;package demo.filerw.service;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import android.content.Context;
import android.os.Environment;
/**
* 文件操作类
* @author janrone
*/
public class FileService {
   private Context context;
   public FileService(Context context) {
       this.context = context;
   }
   //存储数据到文件
   public void saveName(String name) throws Exception{
       //context.getFilesDir();// 得到存放文件的系统目录 /data/data/&amp;lt;package name&amp;gt;/files
       //context.getCacheDir(); //缓存目录  /data/data/&amp;lt;package name&amp;gt;/cache
       FileOutputStream outputStream=context.openFileOutput(“deomfilerw.txt”, Context.MODE_APPEND);
       outputStream.write(name.getBytes());
       outputStream.close();
   }
   //存储数据到sdcard
   public void saveNameToSDCard(String name) throws Exception{
       Environment.getExternalStorageDirectory(); //得到sdcard目录
        File file=new File(“/sdcard”,”demosdcard.txt”);
        FileOutputStream outputStream=new FileOutputStream(file);
        outputStream.write(name.getBytes());
        outputStream.close();
    }
    // 读取数据
    public String getName() throws Exception{
        FileInputStream inputStream=context.openFileInput(“deomfilerw.txt”);
        ByteArrayOutputStream outStream=new ByteArrayOutputStream();
        byte[] buffer=new byte[1024];
        int len=0;
        while ((len=inputStream.read(buffer))!=-1){
            outStream.write(buffer, 0, len);
        }
        outStream.close();
        byte[] data=outStream.toByteArray();
        String name=new String(data);
        return name;
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>TextView 设置中划线下划线等各种效果</title>
      <link>https://janrone.allone.top/posts/2015-12-29-textview-%E8%AE%BE%E7%BD%AE%E4%B8%AD%E5%88%92%E7%BA%BF%E4%B8%8B%E5%88%92%E7%BA%BF/</link>
      <pubDate>Wed, 25 Jul 2012 15:25:15 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2015-12-29-textview-%E8%AE%BE%E7%BD%AE%E4%B8%AD%E5%88%92%E7%BA%BF%E4%B8%8B%E5%88%92%E7%BA%BF/</guid>
      <description>android:textAppearance    设置文字外观。如“?android:attr/textAppearanceLargeInverse
”这里引用的是系统自带的一个外观，？表示系统是否有这种外观，否则使用默认的外观。可设置的值如下：
textAppearanceButton/ textAppearanceInverse/ textAppearanceLarge/ textAppearanceLargeInverse/ textAppearanceMedium/ textAppearanceMediumInverse/ textAppearanceSmall/ textAppearanceSmallInverse  textView.getPaint().setFlags(Paint. UNDERLINE_TEXT_FLAG ); //下划线 textView.getPaint().setAntiAlias(true);//抗锯齿 textview.getPaint().setFlags(Paint. STRIKE_THRU_TEXT_FLAG); //中划线 setFlags(Paint. STRIKE_THRU_TEXT_FLAG|Paint.ANTI_ALIAS_FLAG); // 设置中划线并加清晰 textView.getPaint().setFlags(0); // 取消设置的的划线  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://janrone.allone.top/tools/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://janrone.allone.top/tools/</guid>
      <description>我的工具收集箱    反向词典——清华大学开源的 https://wantwords.thunlp.org/</description>
    </item>
    
  </channel>
</rss>
