<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术 on Janrone‘s Site</title>
    <link>https://janrone.allone.top/categories/%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 技术 on Janrone‘s Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 04 Apr 2018 16:36:09 +0800</lastBuildDate><atom:link href="https://janrone.allone.top/categories/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>三种碰撞检测</title>
      <link>https://janrone.allone.top/posts/2018-04-28-%E4%B8%89%E7%A7%8D%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/</link>
      <pubDate>Wed, 04 Apr 2018 16:36:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2018-04-28-%E4%B8%89%E7%A7%8D%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/</guid>
      <description>碰撞检测    碰撞检测技术 可通过多种方式检测 sprite 之间的碰撞。可采用的三种流行技术（按先进程度和复杂度递增顺序排列）是：
边界区域（在 3D 游戏中称为包围体） 光线投射 分离轴定理 (Separating Axis Theorem) 使用边界区域的碰撞检测，检测圆圈或多边形的交点。在 图 2 中的示例中，小圆圈是表示一个 sprite（一个小球）的边界区域，大圆圈是一个桶的 sprite 的边界区域，桶比球大。当两个圆形边界区域相交时，球就会掉落到桶中。
图 2. 边界区域：圆圈之间的碰撞 该图演示了圆圈之间的碰撞检测的原理 检测两个圆圈的碰撞是所有碰撞检测技术中最简单的。如果两个圆圈中心之间距离小于圆圈的半径之和，就会相交，sprite 就会爆炸。
边界区域碰撞检测很简单，但当边界区域太小或移动得太快时，检测可能失败。在这两种情况下，sprite 可在单个动画帧中彼此穿过，进而避免检测。
对于小型、快速移动的 sprite，更加可靠的一种技术是光线投射，如 图 3 所示。光线投射检测两个 sprite 的速度向量的焦点。在 图 3 中的 5 个帧中，球的速度向量是以蓝色绘制的对角线，桶的速度向量是红色的水平线（桶水平移动）。在这些向量的交点位于桶顶部的开口内，并且球在开口下方时，球就会落入桶中，如 图 3 中最右边的屏幕截图中所示。
图 3. 光线投射 该图演示了光线投射碰撞检测的原理 先验或后验碰撞检测 可在碰撞发生之前（先验）或之后（后验）它们。如果在碰撞发生之前进行检测，必须预测 sprite 未来将位于何处。如果在碰撞发生之后检测，通常需要将已碰撞的 sprite 分开。这两种方法孰优孰劣并不明显。
光线投射非常适合以下环境中的简单形状（比如 图 2 中球落在桶中），其中给出了两个形状的速度向量的焦点，很容易确定它们是否已经发生碰撞。
对于更复杂的场景，比如任意大小和形状的多边形之间的碰撞，分离轴定理是最可靠的（和最复杂的）碰撞检测技术之一。分离轴定理是将光线从两个不同的角度照射到两个多边形上的数学描述，如 图 4 中所示。如果多边形背后的墙上的影子露出空隙，那么多边形没有发生碰撞。
图 4. 分离轴定理 该图演示了使用分离轴定理的碰撞检测的原理 本文不会进一步介绍光线投射或分离轴定理。您可以在 Core HTML5 Canvas（Prentice Hall，2012 年）中查阅每种方法的深入讨论。（请参阅 参考资料，获取相关链接。）</description>
    </item>
    
    <item>
      <title>如何在Excel中使用宏 (版本2013)</title>
      <link>https://janrone.allone.top/posts/2018-04-04-%E5%A6%82%E4%BD%95%E5%9C%A8excel%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%8F/</link>
      <pubDate>Wed, 04 Apr 2018 16:36:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2018-04-04-%E5%A6%82%E4%BD%95%E5%9C%A8excel%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%8F/</guid>
      <description>需求获取网页数据到Excel，用来统计。    1，创建宏：    新建Excel文档，点击视图，点击宏，创建 ，之后是编写宏。保存的时候，遇到到如下问题： 单击否，然后保存文件为 .xlsm 格式 。</description>
    </item>
    
    <item>
      <title>如何删除git历史记录</title>
      <link>https://janrone.allone.top/posts/2018-03-16-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4git%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Fri, 16 Mar 2018 10:36:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2018-03-16-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4git%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</guid>
      <description>清除所有历史    Step 1: remove all history
rm -rf .git  Step 2: reconstruct the Git repo with only the current content
git init git add . git commit -m &amp;quot;Initial commit&amp;quot;  Step 3: push to GitHub.
git remote add origin &amp;lt;github-uri&amp;gt; git push -u --force origin master  清空上某个文件的历史    首先cd 进入项目文件夹下，然后执行以下代码：
git filter-branch --force --index-filter &#39;git rm --cached --ignore-unmatch 文件名&#39; --prune-empty --tag-name-filter cat -- --all git push origin master --force rm -rf .</description>
    </item>
    
    <item>
      <title>JSON 解析时自动判断是Object还是Array</title>
      <link>https://janrone.allone.top/posts/2017-12-28-json-%E8%A7%A3%E6%9E%90%E6%97%B6%E8%87%AA%E5%8A%A8%E5%88%A4%E6%96%AD%E6%98%AFobject%E8%BF%98%E6%98%AFarray/</link>
      <pubDate>Fri, 17 Nov 2017 14:36:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2017-12-28-json-%E8%A7%A3%E6%9E%90%E6%97%B6%E8%87%AA%E5%8A%A8%E5%88%A4%E6%96%AD%E6%98%AFobject%E8%BF%98%E6%98%AFarray/</guid>
      <description>后端API数据返回有时候是Object有时候有是Array！    解决方案：通过JSONTokener解析，JSONTokener在解析过程中可以自动转换为对应的类型
代码示例如下：
 String json =&amp;quot;{\&amp;quot;scm\&amp;quot;:{\&amp;quot;key1\&amp;quot;:\&amp;quot;vlaue1\&amp;quot;,\&amp;quot;key2\&amp;quot;:\&amp;quot;vlaue2\&amp;quot;}}&amp;quot;; String json =&amp;quot;{\&amp;quot;scm\&amp;quot;:[{\&amp;quot;key1\&amp;quot;:\&amp;quot;vlaue1\&amp;quot;,\&amp;quot;key2\&amp;quot;:\&amp;quot;vlaue2\&amp;quot;},{\&amp;quot;key11\&amp;quot;:\&amp;quot;vlaue11\&amp;quot;,\&amp;quot;key22\&amp;quot;:\&amp;quot;vlaue22\&amp;quot;}]}&amp;quot;; JSONObject jsonObject =JSONObject.fromObject(json); Object listArray = new JSONTokener(jsonObject.getString(&amp;quot;scm&amp;quot;)).nextValue(); if (listArray instanceof JSONArray){ JSONArray jsonArray = (JSONArray)listArray; for (int k = 0; k &amp;lt; jsonArray.size(); k++) { JSONObject parameterObject = jsonArray.getJSONObject(k); } }else if (listArray instanceof JSONObject) { JSONObject jsonObject3 = (JSONObject)listArray; }  最后搞定 。
参考：http://blog.csdn.net/xlyrh/article/details/75091353</description>
    </item>
    
    <item>
      <title>Scrapy安装和问题处理</title>
      <link>https://janrone.allone.top/posts/2017-11-17-scrapy%E5%AE%89%E8%A3%85%E5%92%8C%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 17 Nov 2017 14:36:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2017-11-17-scrapy%E5%AE%89%E8%A3%85%E5%92%8C%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</guid>
      <description>安装 scrapy    windows 安装
pip install Scrapy  结果报错：
building &#39;twisted.test.raiser&#39; extension error: [WinError 2] 系统找不到指定的文件。  +++ Command &amp;ldquo;d:\python\python.exe -u -c &amp;ldquo;import setuptools, tokenize;file=&amp;lsquo;C:\Users\Tuteng\AppData\Local\Temp \pip-build-l7ra5rw5\Twisted\setup.py&amp;rsquo;;f=getattr(tokeniz e, &amp;lsquo;open&amp;rsquo;, open)(file);code=f.read().replace(&#39;\r\n&#39;, &amp;lsquo;\n&amp;rsquo;);f.close();exec(compile(code, file, &amp;lsquo;exec&amp;rsquo;))&amp;rdquo; install &amp;ndash;record C:\Users\Tuteng\AppData\Local\Temp\pip-yon9xl5j-record\ins tall-record.txt &amp;ndash;single-version-externally-managed &amp;ndash;compile&amp;rdquo; failed with error code 1 in C:\Users\Tuteng\AppData\Local\Temp\pip-build-l7ra5rw5\Twis ted\
因为scrapy框架是基于twisted 的， 所以又要去上面那个网站： http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml
搜Twisted    Twisted, an event-driven networking engine. Twisted, an event-driven networking engine. ● Twisted‑17.9.0‑cp27‑cp27m‑win32.whl ● Twisted‑17.</description>
    </item>
    
    <item>
      <title>使用Gradle构建多个不同applicationId包</title>
      <link>https://janrone.allone.top/posts/2017-05-13-%E4%BD%BF%E7%94%A8gradle%E6%9E%84%E5%BB%BA%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8Capplicationid%E5%8C%85/</link>
      <pubDate>Sat, 13 May 2017 14:36:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2017-05-13-%E4%BD%BF%E7%94%A8gradle%E6%9E%84%E5%BB%BA%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8Capplicationid%E5%8C%85/</guid>
      <description>假设下面是我们的目前的代码，想要哪个地址就改下API_URL重新打个包就ok了
public static final String API_URL = &amp;ldquo;http://www.google.com&amp;rdquo;;//美国us// public static final String API_URL = &amp;ldquo;http://www.nanfei.com&amp;rdquo;;//南非za public static final String API_URL = &amp;ldquo;http://www.baidu.com&amp;rdquo;;//本地
localRetrofit retrofit = new Retrofit.Builder().baseUrl(API_URL).client(client).addConverterFactory(GsonConverterFactory.create()) .build();
可是有一天，测试同事跑来说，每次测试不同版本只能安装一个app(applicationId是唯一的,会进行覆盖),他想在同一台手机上安装多个app，app之间的区别只是它们的后台服务接口地址API_URL不同，当然最好app的桌面名字能区分出来是哪个服务接口地址,这样测试就方便了
如何实现呢，同时打多个包肯定会想到用productFlavors，同时API_URL和app_name需要动态改变。
1.移除strings的app_name    由于app_name是动态的所以肯定不能写死了,把它删掉
2.设置build.gradle的productFlavors    productFlavors { local { applicationId &amp;ldquo;com.lwp.app&amp;rdquo; buildConfigField &amp;lsquo;String&amp;rsquo;, &amp;lsquo;API_URL&amp;rsquo;, &amp;lsquo;&amp;ldquo;http://www.baidu.com&amp;rdquo;&amp;rsquo; resValue &amp;ldquo;string&amp;rdquo;, &amp;ldquo;app_name&amp;rdquo;, &amp;ldquo;app&amp;rdquo;
} us { applicationId &amp;ldquo;com.lwp.app.us&amp;rdquo; buildConfigField &amp;lsquo;String&amp;rsquo;, &amp;lsquo;API_URL&amp;rsquo;, &amp;lsquo;&amp;ldquo;http://www.google.com&amp;rdquo;&amp;rsquo; resValue &amp;ldquo;string&amp;rdquo;, &amp;ldquo;app_name&amp;rdquo;, &amp;ldquo;app_us&amp;rdquo;
} za { applicationId &amp;ldquo;com.</description>
    </item>
    
    <item>
      <title>Shell命令</title>
      <link>https://janrone.allone.top/posts/2016-05-29-shell%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sun, 29 May 2016 20:36:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2016-05-29-shell%E5%91%BD%E4%BB%A4/</guid>
      <description>###（一）文件创建命令
1.touch命令    例如：touch abc命令在本地目录中创建了一个名为abc的空文件  2.cp命令    cp命令允许我们把一个文件的内容复制到同名或不同名的文件中，复制得到的文件可以在任何目录。 使用cp命令的一个风险	是它会在不提示用户的情况下很容易覆盖掉不同目录中的文件 -r选项支持递归复制。例如：cp -ar /usr/share/doc/. /doc/ 将复制源目录中所有子目录以及相关文件  3.mv命令    mv命令实质上市给文件贴上不同的标签，例如：mv file1 file2 命令就是把file1的名字改为file2 mv命令也可以用于目录  4.ln命令    链接文件允许用户编辑不同目录中的同一个文件 硬链接包含了文件的一个副本。只要硬链接文件是在同一个分区中，则它们的索引号相同 。 ln /etc/samba/smb.conf smb.conf 软连接起着重定向的作用。当我们打开一个用软链接创建的文件时，则链接把我们重定向到原来的文件。 ln -s /etc/	samba/smb.conf smb.conf  5.rm命令    -r开关选项可以按递归方式进行 -f开关选项可以覆盖掉任何安全措施 rm -rf /root/a/b  6.目录创建和删除    mkdir和rmdir命令用于创建和删除目录 -p no error if existing, make parent directories as needed 例如 mkdir -p /test1/test2/test3 rmdir -p /test1/test2/test3  7.</description>
    </item>
    
    <item>
      <title>利用Daocloud持续部署Hexo</title>
      <link>https://janrone.allone.top/posts/2016-05-10-%E5%88%A9%E7%94%A8daocloud%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2hexo/</link>
      <pubDate>Tue, 10 May 2016 13:25:42 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2016-05-10-%E5%88%A9%E7%94%A8daocloud%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2hexo/</guid>
      <description>Hexo安装    npm install -g hexo //安装完成后，进入到Hexo文件夹目录， 即会自动在目标文件夹建立网站所需要的所有文件。 hexo init //初始化 npm install //安装依赖包 hexo g //生成静态的网页 hexo s //开启本地服务，可以在本地预览 Hexo d //上传生产的文件到配置的服务仓库（见_config.yml）  官方文档：https://hexo.io/docs/
同时部署到Coding和Github平台    Coding Pages    Coding Pages 是一个免费的静态网页托管和演示服务。
在Coding创建一个和你用户相同项目用来部署你的Hexo 。
同时在代码选项开启的你的 pages服务。分支填写master(这里的分支要和部署时的对应)。
用户 Pages 可以通过{user_name}.coding.me 形式的 URL 直接访问。
官方文档 https://coding.net/help/doc/pages/index.html
Github pages    同样Gtihub也提供了一个 Pages免费服务。 同样你在Github创建一个名为username.github.io的仓库 。用来部署你的Hexo代码。
官方文档 https://pages.github.com/
_config.yml配置    同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下
deploy: type: git repo: github: &amp;lt;repository url&amp;gt;,[branch] coding: &amp;lt;repository url&amp;gt;,[branch]  Daocloud 自动构建    项目主页：http://daocloud.</description>
    </item>
    
    <item>
      <title>Mac上Ruby和RubyGems安装使用说明</title>
      <link>https://janrone.allone.top/posts/2016-03-26-mac%E4%B8%8Aruby%E5%92%8Crubygems%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Sat, 26 Mar 2016 15:52:33 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2016-03-26-mac%E4%B8%8Aruby%E5%92%8Crubygems%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</guid>
      <description>安装 RVM    RVM:Ruby Version Manager,Ruby版本管理器，包括Ruby的版本管理和Gem库管理(gemset)
　$ curl -L https://get.rvm.io | bash -s stable 然后，载入 RVM 环境    　$ source ~/.rvm/scripts/rvm
查看当前ruby版本    $ ruby -v ruby 1.8.7 #列出已知的ruby版本 $ rvm list known #安装ruby 1.9.3 $ rvm install 1.9.3 步骤3 － 设置 Ruby 版本  RVM 装好以后，需要执行下面的命令将指定版本的 Ruby 设置为系统默认版本
　$ rvm 2.0.0 &amp;ndash;default 有可能是因为Ruby的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，网上的一种解决方案是将远替换成淘宝的，替换方式如下：
$ gem source -r https://rubygems.org/ $ gem source -a https://ruby.</description>
    </item>
    
    <item>
      <title>Mac下安装及配置 ProxyChains-NG 实现终端下代理</title>
      <link>https://janrone.allone.top/posts/2016-03-26-mac%E4%B8%8B%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-proxychains-ng-%E5%AE%9E%E7%8E%B0%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%BB%A3%E7%90%86/</link>
      <pubDate>Sat, 26 Mar 2016 13:30:42 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2016-03-26-mac%E4%B8%8B%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE-proxychains-ng-%E5%AE%9E%E7%8E%B0%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%BB%A3%E7%90%86/</guid>
      <description>ProxyChains-NG    项目主页：https://github.com/rofl0r/proxychains-ng
官方说明：
proxychains ng (new generation) - a preloader which hooks calls to sockets in dynamically linked programs and redirects it through one or more socks/http proxies. continuation of the unmaintained proxychains project.
安装    使用 Homebrew 安装
brew install proxychains-ng
配置    编辑配置文件
sudo vim /usr/local/Cellar/proxychains-ng/4.10/etc/proxychains.conf  在 [ProxyList] 下面（也就是末尾）加入代理类型，代理地址和端口 注释掉原来的代理并添加
socks5 127.0.0.1 1080  ps: 默认的socks4 127.0.0.1 9095是tor代理，而socks5 127.0.0.1 1080是shadowsocks的代理。</description>
    </item>
    
    <item>
      <title>Java IO中几个主要类介绍和使用</title>
      <link>https://janrone.allone.top/posts/2016-01-05-java-io-%E5%87%A0%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 05 Jan 2016 10:55:41 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2016-01-05-java-io-%E5%87%A0%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;h4 id=&#34;1-io流可以有三种分类方法&#34;&gt;
  1. I/O流可以有三种分类方法.
  &lt;a class=&#34;heading-link&#34; href=&#34;#1-io%e6%b5%81%e5%8f%af%e4%bb%a5%e6%9c%89%e4%b8%89%e7%a7%8d%e5%88%86%e7%b1%bb%e6%96%b9%e6%b3%95&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;第一, 输入流,输出流 .
第二, 字节流,字符流 . 
第三, 节点流(真正直接处理数据的) ,处理流(装饰加工节点流的) .
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-字节流&#34;&gt;
  2. 字节流
  &lt;a class=&#34;heading-link&#34; href=&#34;#2-%e5%ad%97%e8%8a%82%e6%b5%81&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;抽象类 &amp;lt;– 面向字节的文件流 .  
InputStream &amp;lt;– FileInputStream  
OutputStream &amp;lt;– FileOutputStream  

常用方法 
InputStream  int read(byte [] c,int off, int len)  
OutputStream voidwrite(byte [] c,int off, int len) .
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-字符流&#34;&gt;
  3. 字符流
  &lt;a class=&#34;heading-link&#34; href=&#34;#3-%e5%ad%97%e7%ac%a6%e6%b5%81&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;抽象类 &amp;lt;– 面向字符文件流 .
Reader &amp;lt;– FileReader 
Writer &amp;lt;— FileWriter 

常用方法 
FileReader int read(char [] c,int off, int len)   
FileWriter voidwrite(char [] c,int off, int len) .
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-节点流和处理流&#34;&gt;
  4. 节点流和处理流
  &lt;a class=&#34;heading-link&#34; href=&#34;#4-%e8%8a%82%e7%82%b9%e6%b5%81%e5%92%8c%e5%a4%84%e7%90%86%e6%b5%81&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;类
BufferdReader 可以称作字符、输入、处理流 .

方法
String readLine()

BufferdReader构造函数接受的是 Reader 类型的参数
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Android Studio 开发遇到错误和解决方法集合</title>
      <link>https://janrone.allone.top/posts/2015-12-29-android-studio-%E5%BC%80%E5%8F%91android%E9%81%87%E5%88%B0%E9%94%99%E8%AF%AF%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88/</link>
      <pubDate>Tue, 29 Dec 2015 19:28:59 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2015-12-29-android-studio-%E5%BC%80%E5%8F%91android%E9%81%87%E5%88%B0%E9%94%99%E8%AF%AF%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88/</guid>
      <description>1 .Duplicate files copied in APK META-INF/LICENSE.txt    android { packagingOptions { exclude &#39;META-INF/LICENSE.txt&#39; } } My logcat: log Execution failed for task &#39;:Prog:packageDebug&#39;. Duplicate files copied in APK META-INF/LICENSE.txt File 1: /home/scijoker/AndroidStudioProjects/ProgProject/Prog/libs/httpclient-4.1.1.jar File 2: /home/scijoker/AndroidStudioProjects/ProgProject/Prog/libs/httpclient-4.1.1.jar  解决方法    android { packagingOptions { exclude &#39;META-INF/DEPENDENCIES.txt&#39; exclude &#39;META-INF/LICENSE.txt&#39; exclude &#39;META-INF/NOTICE.txt&#39; exclude &#39;META-INF/NOTICE&#39; exclude &#39;META-INF/LICENSE&#39; exclude &#39;META-INF/DEPENDENCIES&#39; exclude &#39;META-INF/notice.txt&#39; exclude &#39;META-INF/license.txt&#39; exclude &#39;META-INF/dependencies.txt&#39; exclude &#39;META-INF/LGPL2.1&#39; } }  2 .</description>
    </item>
    
    <item>
      <title>使用Gradle命令打包Android应用</title>
      <link>https://janrone.allone.top/posts/2015-12-23-%E4%BD%BF%E7%94%A8gradle%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85android%E5%BA%94%E7%94%A8/</link>
      <pubDate>Wed, 23 Dec 2015 11:52:09 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2015-12-23-%E4%BD%BF%E7%94%A8gradle%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85android%E5%BA%94%E7%94%A8/</guid>
      <description>gradlew －－ gradle wrapper    ./gradlew -v 版本号 ./gradlew clean app目录下的build文件夹 ./gradlew build 检查依赖并编译打包,同时把debug、release环境的包都打出来。 ./gradlew installRelease Release模式打包并安装 ./gradlew uninstallRelease 卸载Release模式包 配合assemble ./gradlew assembleDebug 编译并打Debug包 ./gradlew assembleRelease 编译并打Release的包  其实 assemble 是和 Build Variants 一起结合使用的，而 Build Variants = Build Type + Product Flavor 除此之外 assemble 还能和 Product Flavor 结合创建新的任务，    ./gradlew assembleWandoujiaRelease 生成wandoujia渠道的release版本 ./gradlew assembleWandoujia 生成wandoujia渠道的Release和Debug版本 ./gradlew assembleRelease 生成全部渠道Release版本。即生成Product Flavor下的所有渠道的Release版本都打出来。  总结一下，assemble 命令创建task有如下用法：    **assemble**： 允许直接构建一个Variant版本，例如assembleFlavor1Debug。 **assemble**： 允许构建指定Build Type的所有APK，例如assembleDebug将会构建Flavor1Debug和Flavor2Debug两个Variant版本。 **assemble**： 允许构建指定flavor的所有APK，例如assembleFlavor1将会构建Flavor1Debug和Flavor1Release两个Variant版本。  最佳实践    signingConfigs { release { try { storeFile file(&amp;quot;xxxx&amp;quot;) storePassword KEYSTORE_PASSWORD keyAlias &amp;quot;xxxxx&amp;quot; keyPassword KEY_PASSWORD } catch (ex) { throw new InvalidUserDataException(&amp;quot;You should define KEYSTORE_PASSWORD and KEY_PASSWORD in gradle.</description>
    </item>
    
    <item>
      <title>在Android上搭建Python环境</title>
      <link>https://janrone.allone.top/posts/2013-04-09-%E5%9C%A8android%E4%B8%8A%E6%90%AD%E5%BB%BApython%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Tue, 09 Apr 2013 14:00:11 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2013-04-09-%E5%9C%A8android%E4%B8%8A%E6%90%AD%E5%BB%BApython%E7%8E%AF%E5%A2%83/</guid>
      <description>&lt;h3 id=&#34;1下载和安装-scripting-layer-for-android-sl4a&#34;&gt;
  1.下载和安装 Scripting Layer for Android (SL4A)
  &lt;a class=&#34;heading-link&#34; href=&#34;#1%e4%b8%8b%e8%bd%bd%e5%92%8c%e5%ae%89%e8%a3%85-scripting-layer-for-android-sl4a&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;Scripting Layer for Android (SL4A) 是一个开源项目，目标是为android系统提供脚本语言的支持，使用户可以直接在android平台上进行脚本语言的编辑、解释和执行。这些脚本语言已 经可是使用很多封装好的android API来开发功能丰富的android应用程序，并且使开发变得更加的简单和高效!
这个平台支持多种脚本语言，比如 Python, Perl, JRuby, Lua, BeanShell, JavaScript, Tcl, shell 等，你可以选择你熟悉的语言进行开发，本系列教程使用Python为编程脚本语言。
SL4A项目的地址: &lt;a href=&#34;http://code.google.com/p/android-scripting/&#34;&gt;http://code.google.com/p/android-scripting/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;2下载和安装-python-for-android&#34;&gt;
  2.下载和安装 Python for android
  &lt;a class=&#34;heading-link&#34; href=&#34;#2%e4%b8%8b%e8%bd%bd%e5%92%8c%e5%ae%89%e8%a3%85-python-for-android&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;在项目主页面的右上方，有该应用支持的所有脚本语言的下载列表，如下图所示;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://janrone.allone.top/images/post/2013-04-09-01.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>怎么在github 搭建 Octopress </title>
      <link>https://janrone.allone.top/posts/2013-01-12-%E6%80%8E%E4%B9%88%E6%90%AD%E5%BB%BAoctopress%E5%9C%A8github/</link>
      <pubDate>Sat, 12 Jan 2013 20:34:13 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2013-01-12-%E6%80%8E%E4%B9%88%E6%90%AD%E5%BB%BAoctopress%E5%9C%A8github/</guid>
      <description>git 和 github 配置    1.先注册一个github账号， 创建github pages 。    创建一个新的Repository。这里须要重视的是，若是想要博客的首页是http://yourname.github.com，则Repository的project name就必须是yourname.github.com。
安装Git并进行设置，mac下git默认已经装好 。
2.接下来设置 SH Keys .    履行ssh-keygen -t rsa -C &amp;ldquo;your_email＠youremail.com&amp;rdquo;，回车。
然后输入两遍暗码。
到c:\Users\用户名.ssh\目次找到id_rsa.pub，并用文本软件打开复制全部。目录是隐藏的。
3.将SSH Key添加到GitHub    到github网站选择“Account Settings”&amp;raquo;“SSH Public Keys”&amp;raquo;“Add another public key”，将刚才复制的内容粘贴到key文本框内。
4. 测试    为确保设置成功，现在可以测试设置成果啦。记住，&amp;ldquo;git@github.com&amp;quot;是默认的，无需修改。
 $ ssh -T git@github.com （也可以用 SSH -v git@github.com ）  5.设置个人信息    现在，你已经成功安装Git，并设置好SSH Keys，是设置个人信息的时候啦：
设置用户名和电子邮件 $ git config &amp;ndash;global user.</description>
    </item>
    
    <item>
      <title>Android 用openFileOutput 和 openFileInput操作文件</title>
      <link>https://janrone.allone.top/posts/android-%E7%94%A8openfileoutput-%E5%92%8C-openfileinput%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6/</link>
      <pubDate>Sun, 11 Nov 2012 15:44:13 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/android-%E7%94%A8openfileoutput-%E5%92%8C-openfileinput%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6/</guid>
      <description>&lt;h5 id=&#34;照旧废话不说-贴代码&#34;&gt;
  照旧废话不说 贴代码
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e7%85%a7%e6%97%a7%e5%ba%9f%e8%af%9d%e4%b8%8d%e8%af%b4-%e8%b4%b4%e4%bb%a3%e7%a0%81&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h5&gt;
&lt;h5 id=&#34;文件操作类&#34;&gt;
  文件操作类
  &lt;a class=&#34;heading-link&#34; href=&#34;#%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c%e7%b1%bb&#34;&gt;
    &lt;i class=&#34;fa fa-link&#34; aria-hidden=&#34;true&#34;&gt;&lt;/i&gt;
  &lt;/a&gt;
&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;package demo.filerw.service;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import android.content.Context;
import android.os.Environment;
/**
* 文件操作类
* @author janrone
*/
public class FileService {
   private Context context;
   public FileService(Context context) {
       this.context = context;
   }
   //存储数据到文件
   public void saveName(String name) throws Exception{
       //context.getFilesDir();// 得到存放文件的系统目录 /data/data/&amp;lt;package name&amp;gt;/files
       //context.getCacheDir(); //缓存目录  /data/data/&amp;lt;package name&amp;gt;/cache
       FileOutputStream outputStream=context.openFileOutput(“deomfilerw.txt”, Context.MODE_APPEND);
       outputStream.write(name.getBytes());
       outputStream.close();
   }
   //存储数据到sdcard
   public void saveNameToSDCard(String name) throws Exception{
       Environment.getExternalStorageDirectory(); //得到sdcard目录
        File file=new File(“/sdcard”,”demosdcard.txt”);
        FileOutputStream outputStream=new FileOutputStream(file);
        outputStream.write(name.getBytes());
        outputStream.close();
    }
    // 读取数据
    public String getName() throws Exception{
        FileInputStream inputStream=context.openFileInput(“deomfilerw.txt”);
        ByteArrayOutputStream outStream=new ByteArrayOutputStream();
        byte[] buffer=new byte[1024];
        int len=0;
        while ((len=inputStream.read(buffer))!=-1){
            outStream.write(buffer, 0, len);
        }
        outStream.close();
        byte[] data=outStream.toByteArray();
        String name=new String(data);
        return name;
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>TextView 设置中划线下划线等各种效果</title>
      <link>https://janrone.allone.top/posts/2015-12-29-textview-%E8%AE%BE%E7%BD%AE%E4%B8%AD%E5%88%92%E7%BA%BF%E4%B8%8B%E5%88%92%E7%BA%BF/</link>
      <pubDate>Wed, 25 Jul 2012 15:25:15 +0800</pubDate>
      
      <guid>https://janrone.allone.top/posts/2015-12-29-textview-%E8%AE%BE%E7%BD%AE%E4%B8%AD%E5%88%92%E7%BA%BF%E4%B8%8B%E5%88%92%E7%BA%BF/</guid>
      <description>android:textAppearance    设置文字外观。如“?android:attr/textAppearanceLargeInverse
”这里引用的是系统自带的一个外观，？表示系统是否有这种外观，否则使用默认的外观。可设置的值如下：
textAppearanceButton/ textAppearanceInverse/ textAppearanceLarge/ textAppearanceLargeInverse/ textAppearanceMedium/ textAppearanceMediumInverse/ textAppearanceSmall/ textAppearanceSmallInverse  textView.getPaint().setFlags(Paint. UNDERLINE_TEXT_FLAG ); //下划线 textView.getPaint().setAntiAlias(true);//抗锯齿 textview.getPaint().setFlags(Paint. STRIKE_THRU_TEXT_FLAG); //中划线 setFlags(Paint. STRIKE_THRU_TEXT_FLAG|Paint.ANTI_ALIAS_FLAG); // 设置中划线并加清晰 textView.getPaint().setFlags(0); // 取消设置的的划线  </description>
    </item>
    
  </channel>
</rss>
